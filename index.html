<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Particle Universe + Local Procedural Core</title>
    <style>
        /* --- 全局设置 --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- 全息 UI 面板容器 --- */
        #hologram-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 360px; /* 加宽以容纳更多控件 */
            pointer-events: none;
            z-index: 10;
            max-height: 90vh; /* 防止过高 */
            overflow-y: auto; /* 允许内容过多时滚动 */
            scrollbar-width: none; /* 隐藏滚动条(Firefox) */
        }
        #hologram-ui::-webkit-scrollbar { display: none; } /* 隐藏滚动条(Chrome) */

        /* 面板框架 */
        .panel-frame {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid rgba(0, 255, 255, 0.8);
            padding: 15px;
            backdrop-filter: blur(6px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            position: relative;
            overflow: hidden;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        /* 扫描线动画 */
        .panel-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 255, 0.5);
            animation: scan 3s linear infinite;
            opacity: 0.3;
            pointer-events: none;
        }

        @keyframes scan {
            0% { top: 0; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        /* 文本样式 */
        h1 {
            color: #0ff;
            font-size: 16px;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #0ff;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fps-badge {
            font-size: 12px;
            background: rgba(0, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 2px;
        }

        /* --- 交互式数据行 --- */
        .control-section {
            margin-bottom: 15px;
            border-bottom: 1px dashed rgba(0,255,255,0.2);
            padding-bottom: 10px;
        }
        
        .section-title {
            color: #0ff;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 8px;
            opacity: 0.8;
        }

        .control-row {
            margin-bottom: 8px;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center; /* 垂直居中 */
            color: rgba(0, 255, 255, 0.8);
            font-size: 10px;
            margin-bottom: 2px;
        }

        .control-value {
            color: #fff;
            font-weight: bold;
        }

        /* 刷新按钮样式 */
        .refresh-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            color: #0ff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 10px;
            margin-left: 6px;
            transition: all 0.2s;
        }
        .refresh-btn:hover {
            background: #0ff;
            color: #000;
            transform: rotate(180deg);
        }

        /* 科幻滑块样式 */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 0;
        }

        input[type=range]:focus { outline: none; }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-radius: 0;
        }

        input[type=range]::-webkit-slider-thumb {
            height: 12px;
            width: 8px;
            border: 1px solid #0ff;
            background: #000;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            box-shadow: 0 0 5px #0ff;
            transition: background 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover { background: #0ff; }

        /* RGB 滑块特定颜色 */
        .slider-red::-webkit-slider-runnable-track { background: rgba(255, 0, 0, 0.3); border-color: rgba(255,0,0,0.5); }
        .slider-red::-webkit-slider-thumb { border-color: #f00; box-shadow: 0 0 5px #f00; }
        
        .slider-green::-webkit-slider-runnable-track { background: rgba(0, 255, 0, 0.3); border-color: rgba(0,255,0,0.5); }
        .slider-green::-webkit-slider-thumb { border-color: #0f0; box-shadow: 0 0 5px #0f0; }

        .slider-blue::-webkit-slider-runnable-track { background: rgba(0, 0, 255, 0.3); border-color: rgba(0,0,255,0.5); }
        .slider-blue::-webkit-slider-thumb { border-color: #00f; box-shadow: 0 0 5px #00f; }

        /* --- AI 终端样式 --- */
        .terminal-input-group {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        #ai-input {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            color: #0ff;
            font-family: inherit;
            font-size: 12px;
            padding: 8px;
            width: 100%;
            outline: none;
        }
        
        #ai-input::placeholder { color: rgba(0, 255, 255, 0.3); }

        #ai-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            color: #0ff;
            cursor: pointer;
            font-weight: bold;
            padding: 0 10px;
            font-size: 16px;
            transition: all 0.2s;
        }

        #ai-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 10px #0ff; }
        #ai-btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }

        /* AI 快捷标签 */
        .preset-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .preset-tag {
            font-size: 10px;
            color: rgba(0,255,255,0.7);
            border: 1px solid rgba(0,255,255,0.3);
            padding: 2px 6px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0,0,0,0.3);
        }

        .preset-tag:hover {
            background: rgba(0,255,255,0.2);
            color: #fff;
            border-color: #0ff;
        }

        .ai-log {
            font-size: 10px;
            color: #0f0;
            height: 50px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border: 1px solid rgba(0,255,0,0.2);
            white-space: pre-wrap;
            line-height: 1.4;
        }

        .ai-log::-webkit-scrollbar { width: 4px; }
        .ai-log::-webkit-scrollbar-track { background: #000; }
        .ai-log::-webkit-scrollbar-thumb { background: #0ff; }

        /* --- 底部控制按钮 --- */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .sci-fi-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 10px 20px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .sci-fi-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px #0ff;
            text-shadow: 0 0 8px #0ff;
        }

        .sci-fi-btn.active {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
            font-weight: bold;
        }

        .corner-decoration {
            position: absolute;
            width: 8px;
            height: 8px;
            border: 1px solid #0ff;
            transition: all 0.3s;
        }
        .tl { top: -1px; left: -1px; border-bottom: none; border-right: none; }
        .tr { top: -1px; right: -1px; border-bottom: none; border-left: none; }
        .bl { bottom: -1px; left: -1px; border-top: none; border-right: none; }
        .br { bottom: -1px; right: -1px; border-top: none; border-left: none; }

        /* 加载遮罩 */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #0ff;
            z-index: 100;
            flex-direction: column;
        }
        .loader-bar {
            width: 200px;
            height: 2px;
            background: #333;
            margin-top: 10px;
            position: relative;
        }
        .loader-progress {
            position: absolute;
            left: 0; top: 0; height: 100%;
            background: #0ff;
            width: 0%;
            transition: width 0.2s;
            box-shadow: 0 0 10px #0ff;
        }
    </style>
    <!-- 引入 Three.js 和 Tween.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <!-- 加载动画 -->
    <div id="loader">
        <div>INITIALIZING CORE SYSTEMS...</div>
        <div class="loader-bar"><div class="loader-progress" id="progress"></div></div>
    </div>
    
    <!-- 全息数据面板 -->
    <div id="hologram-ui">
        <div class="panel-frame">
            <h1>
                SYSTEM STATUS
                <span class="fps-badge"><span id="fps-counter">60</span> FPS</span>
            </h1>
            
            <!-- 模拟控制模块 -->
            <div class="control-section">
                <div class="section-title">>> SIMULATION CORE</div>
                <div class="control-row">
                    <div class="control-header">
                        <span>PARTICLE DENSITY</span>
                        <span class="control-value" id="particle-val">20,000</span>
                    </div>
                    <input type="range" id="particle-slider" min="5000" max="50000" step="1000" value="20000">
                </div>

                <div class="control-row">
                    <div class="control-header">
                        <span>TIME DILATION</span>
                        <span class="control-value" id="speed-val">1.0x</span>
                    </div>
                    <input type="range" id="speed-slider" min="0" max="3" step="0.1" value="1.0">
                </div>

                <div class="control-row">
                    <div class="control-header">
                        <span>FIELD STABILITY</span>
                        <span class="control-value" id="stability-val" style="color: #0f0;">100%</span>
                    </div>
                    <input type="range" id="stability-slider" min="0" max="100" step="1" value="100">
                </div>
            </div>

            <!-- 外观控制模块 (新) -->
            <div class="control-section">
                <div class="section-title">>> PARTICLE APPEARANCE</div>
                
                <div class="control-row">
                    <div class="control-header">
                        <span>PARTICLE SIZE</span>
                        <span class="control-value" id="size-val">6.0</span>
                    </div>
                    <input type="range" id="size-slider" min="1" max="20" step="0.1" value="6.0">
                </div>

                <!-- RGB 调色板 -->
                <div class="control-row">
                    <div class="control-header">
                        <span>SPECTRAL FILTER (RGB)</span>
                        <span class="control-value" id="rgb-val">255, 255, 255</span>
                    </div>
                    <!-- R -->
                    <input type="range" class="slider-red" id="slider-r" min="0" max="255" value="255" style="margin-bottom: 4px;">
                    <!-- G -->
                    <input type="range" class="slider-green" id="slider-g" min="0" max="255" value="255" style="margin-bottom: 4px;">
                    <!-- B -->
                    <input type="range" class="slider-blue" id="slider-b" min="0" max="255" value="255">
                </div>

                <!-- 神经树连线 (更新：带刷新按钮) -->
                <div class="control-row">
                    <div class="control-header">
                        <span>NEURAL DENSITY (LINES)</span>
                        <div style="display:flex; align-items:center;">
                            <span class="control-value" id="neural-val" style="margin-right:5px;">0%</span>
                            <div class="refresh-btn" id="btn-refresh-lines" title="Randomize Connections">↻</div>
                        </div>
                    </div>
                    <input type="range" id="neural-slider" min="0" max="100" step="1" value="0">
                </div>

                <!-- 形状变形 -->
                <div class="control-row">
                    <div class="control-header">
                        <span>SHAPE MORPH</span>
                        <span class="control-value" id="shape-val">Glow</span>
                    </div>
                    <input type="range" id="shape-slider" min="0" max="3" step="0.01" value="0">
                </div>
            </div>
            
            <!-- AI 终端区域 (本地过程化生成) -->
            <div class="control-section" style="border:none; margin-bottom:0;">
                <div class="section-title">>> DIMENSIONAL RECONSTRUCTOR</div>
                <div class="terminal-input-group">
                    <input type="text" id="ai-input" placeholder="Input shape (e.g. Galaxy, Cube)..." onkeydown="if(event.key==='Enter') triggerAI()">
                    <button id="ai-btn" onclick="triggerAI()">✨</button>
                </div>
                
                <!-- 快捷预设 -->
                <div class="preset-tags">
                    <div class="preset-tag" onclick="usePreset('Spiral Galaxy')">Galaxy</div>
                    <div class="preset-tag" onclick="usePreset('DNA Double Helix')">DNA</div>
                    <div class="preset-tag" onclick="usePreset('Tornado Storm')">Tornado</div>
                    <div class="preset-tag" onclick="usePreset('Pyramid Grid')">Pyramid</div>
                    <div class="preset-tag" onclick="usePreset('Atomic Structure')">Atom</div>
                    <div class="preset-tag" onclick="usePreset('Cube Matrix')">Matrix</div>
                </div>

                <div class="ai-log" id="ai-log">
                    [SYSTEM] Quantum field ready.
                    [INFO] Use sliders to tint particle spectrum.
                </div>
            </div>
        </div>
    </div>

    <!-- 底部形状切换 -->
    <div id="controls">
        <button class="sci-fi-btn active" onclick="transformTo('universe')">
            <div class="corner-decoration tl"></div><div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div><div class="corner-decoration br"></div>
            Universe
        </button>
        <button class="sci-fi-btn" onclick="transformTo('heart')">
            <div class="corner-decoration tl"></div><div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div><div class="corner-decoration br"></div>
            Heart
        </button>
        <button class="sci-fi-btn" onclick="transformTo('mobius')">
            <div class="corner-decoration tl"></div><div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div><div class="corner-decoration br"></div>
            Möbius
        </button>
        <button class="sci-fi-btn" onclick="transformTo('fractal')">
            <div class="corner-decoration tl"></div><div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div><div class="corner-decoration br"></div>
            Fractal
        </button>
        <button class="sci-fi-btn" onclick="transformTo('penrose')">
            <div class="corner-decoration tl"></div><div class="corner-decoration tr"></div>
            <div class="corner-decoration bl"></div><div class="corner-decoration br"></div>
            Penrose
        </button>
    </div>

    <script>
        // --- 变量声明 ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let linesMesh, linesGeometry; // 连线网格
        let particleCount = 20000;
        const maxLines = 10000; // 增加最大连线数以支持“满连接”
        
        // 控制变量
        let simSpeed = 1.0;
        let stability = 1.0;
        let particleSize = 6.0;
        let neuralDensity = 0; // 0-100
        let shapeMorph = 0.0; // 0.0-3.0
        let lineSeed = 0; // 连线随机种子
        
        // 颜色控制
        let colorR = 1, colorG = 1, colorB = 1; // 0-1 normalized

        let currentShape = 'universe';
        let customShapeCode = null;
        
        // 动画相关
        const transitionParams = { val: 1 };
        let currentTween = null;

        // 性能监控
        let lastTime = performance.now();
        let frames = 0;
        const fpsCounter = document.getElementById('fps-counter');

        // 鼠标交互
        let mouseX = 0;
        let mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        // 辅助随机函数
        const rand = (min, max) => Math.random() * (max - min) + min;

        // 着色器代码 (实现形状平滑变形)
        const vertexShader = `
            uniform float size;
            varying vec3 vColor;
            void main() {
                vColor = color;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                // 根据距离调整大小
                gl_PointSize = size * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform float uShape; // 0.0 - 3.0
            uniform vec3 uColorTint;
            varying vec3 vColor;

            void main() {
                vec2 uv = gl_PointCoord;
                vec3 finalColor = vColor * uColorTint;
                
                // Shape 0: Soft Glow (Gaussian-ish)
                float d = length(uv - 0.5);
                float s0 = exp(-d * d * 8.0); 

                // Shape 1: Diamond / Star-like
                vec2 p = abs(uv - 0.5);
                float s1 = smoothstep(0.4, 0.3, p.x + p.y);

                // Shape 2: Square
                float s2 = smoothstep(0.4, 0.3, max(p.x, p.y));

                // Shape 3: Ring / Donut
                float s3 = smoothstep(0.3, 0.35, d) * smoothstep(0.5, 0.4, d);

                float alpha = 0.0;

                // Mix shapes based on uShape
                if (uShape < 1.0) {
                    alpha = mix(s0, s1, uShape);
                } else if (uShape < 2.0) {
                    alpha = mix(s1, s2, uShape - 1.0);
                } else {
                    alpha = mix(s2, s3, uShape - 2.0);
                }

                if (alpha < 0.01) discard;
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        init();
        setupUIControls();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 4000);
            camera.position.z = 1000;

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClearColor = false;
            document.body.appendChild(renderer.domElement);

            initParticles(particleCount);
            initLines(); // 初始化连线系统

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);

            setTimeout(() => {
                document.getElementById('progress').style.width = "100%";
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => {
                        document.getElementById('loader').style.display = 'none';
                    }, 500);
                }, 300);
            }, 500);
        }

        function initParticles(count) {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
            }

            particleCount = count;

            geometry = new THREE.BufferGeometry();
            
            // 使用 ShaderMaterial 替换原来的 PointsMaterial
            material = new THREE.ShaderMaterial({
                uniforms: {
                    size: { value: particleSize },
                    uShape: { value: shapeMorph },
                    uColorTint: { value: new THREE.Color(colorR, colorG, colorB) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                vertexColors: true
            });

            // 重新计算位置
            let posData;
            if (currentShape === 'custom') {
                posData = getUniverseLayout(); 
            } else {
                switch(currentShape) {
                    case 'heart': posData = getHeartLayout(); break;
                    case 'mobius': posData = getMobiusLayout(); break;
                    case 'fractal': posData = getFractalLayout(); break;
                    case 'penrose': posData = getPenroseLayout(); break;
                    default: posData = getUniverseLayout(); break;
                }
            }
            
            const initialColors = getColors(currentShape === 'custom' ? 'ai' : currentShape);

            const posArray = new Float32Array(particleCount * 3);
            const colArray = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                posArray[i * 3] = posData[i * 3];
                posArray[i * 3 + 1] = posData[i * 3 + 1];
                posArray[i * 3 + 2] = posData[i * 3 + 2];

                colArray[i * 3] = initialColors[i * 3];
                colArray[i * 3 + 1] = initialColors[i * 3 + 1];
                colArray[i * 3 + 2] = initialColors[i * 3 + 2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function initLines() {
            linesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(maxLines * 2 * 3); // 2 points per line, 3 coords
            linesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const linesMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.15, // 淡淡的神经线
                blending: THREE.AdditiveBlending
            });

            linesMesh = new THREE.LineSegments(linesGeometry, linesMaterial);
            linesMesh.frustumCulled = false; // 总是渲染，避免闪烁
            scene.add(linesMesh);
        }

        function updateLines() {
            if (!linesMesh || !particles) return;
            
            // 0% -> 0 lines, 100% -> maxLines
            const activeLines = Math.floor(maxLines * (neuralDensity / 100));
            const positions = linesGeometry.attributes.position.array;
            const particlePositions = particles.geometry.attributes.position.array;
            
            // 将不活动的线段隐藏 (设为 0,0,0)
            for (let i = activeLines * 6; i < maxLines * 6; i++) {
                positions[i] = 0;
            }
            
            if (activeLines === 0) {
                linesGeometry.attributes.position.needsUpdate = true;
                return;
            }
            
            let lineIndex = 0;
            // 步长根据密度动态调整，以确保连线分布均匀，而不是全堆在数组前面
            const step = Math.max(1, Math.floor(particleCount / (activeLines + 1))); 
            
            // 外层循环遍历粒子，试图发起连接
            for (let k = 0; k < particleCount && lineIndex < activeLines; k += step) {
                // 使用 lineSeed 改变起始位置，从而改变连接结构
                let i = (k + lineSeed) % particleCount;
                
                const idx1 = i * 3;
                const x1 = particlePositions[idx1];
                const y1 = particlePositions[idx1+1];
                const z1 = particlePositions[idx1+2];

                // 尝试连接数组中附近的点 (形成结构感)
                for(let j = 1; j <= 3; j++) {
                    if (lineIndex >= activeLines) break;

                    // 目标点也受到 Seed 影响，产生更多变化
                    const targetIdx = (i + j) % particleCount;
                    const idx2 = targetIdx * 3;
                    const x2 = particlePositions[idx2];
                    const y2 = particlePositions[idx2+1];
                    const z2 = particlePositions[idx2+2];

                    // 计算距离
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    const dz = z2 - z1;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    // 阈值：随着密度增加，允许连接更远的点
                    const threshold = 3000 + neuralDensity * 50; 

                    if (distSq < threshold) {
                        const lPos = lineIndex * 6;
                        positions[lPos] = x1;
                        positions[lPos+1] = y1;
                        positions[lPos+2] = z1;
                        
                        positions[lPos+3] = x2;
                        positions[lPos+4] = y2;
                        positions[lPos+5] = z2;
                        
                        lineIndex++;
                    }
                }
            }
            
            linesGeometry.attributes.position.needsUpdate = true;
            linesMesh.rotation.copy(particles.rotation);
        }

        function setupUIControls() {
            // 1. 粒子数量
            const pSlider = document.getElementById('particle-slider');
            const pVal = document.getElementById('particle-val');
            pSlider.addEventListener('change', (e) => {
                const val = parseInt(e.target.value);
                pVal.innerText = val.toLocaleString();
                initParticles(val);
                logSystem(`Re-materializing: ${val} units.`);
            });
            pSlider.addEventListener('input', (e) => {
                pVal.innerText = parseInt(e.target.value).toLocaleString();
            });

            // 2. 速度
            const sSlider = document.getElementById('speed-slider');
            const sVal = document.getElementById('speed-val');
            sSlider.addEventListener('input', (e) => {
                simSpeed = parseFloat(e.target.value);
                sVal.innerText = simSpeed.toFixed(1) + "x";
            });

            // 3. 稳定性
            const stSlider = document.getElementById('stability-slider');
            const stVal = document.getElementById('stability-val');
            stSlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                stability = val / 100;
                stVal.innerText = val + "%";
                if (val > 80) stVal.style.color = "#0f0";
                else if (val > 40) stVal.style.color = "#ff0";
                else stVal.style.color = "#f00";
            });
            
            // 4. 粒子大小
            const sizeSlider = document.getElementById('size-slider');
            const sizeVal = document.getElementById('size-val');
            sizeSlider.addEventListener('input', (e) => {
                particleSize = parseFloat(e.target.value);
                sizeVal.innerText = particleSize.toFixed(1);
                if(material) material.uniforms.size.value = particleSize; // Update uniform
            });

            // 5. RGB 调色
            const rSlider = document.getElementById('slider-r');
            const gSlider = document.getElementById('slider-g');
            const bSlider = document.getElementById('slider-b');
            const rgbVal = document.getElementById('rgb-val');

            function updateColor() {
                const r = parseInt(rSlider.value);
                const g = parseInt(gSlider.value);
                const b = parseInt(bSlider.value);
                rgbVal.innerText = `${r}, ${g}, ${b}`;
                
                colorR = r / 255;
                colorG = g / 255;
                colorB = b / 255;
                
                if(material) {
                    material.uniforms.uColorTint.value.setRGB(colorR, colorG, colorB);
                }
                if(linesMesh) {
                    linesMesh.material.color.setRGB(colorR, colorG * 1.2, colorB * 1.5); // 线条颜色略微不同
                }
            }

            rSlider.addEventListener('input', updateColor);
            gSlider.addEventListener('input', updateColor);
            bSlider.addEventListener('input', updateColor);

            // 6. 神经树密度 & 刷新
            const neuralSlider = document.getElementById('neural-slider');
            const neuralVal = document.getElementById('neural-val');
            const refreshBtn = document.getElementById('btn-refresh-lines');

            neuralSlider.addEventListener('input', (e) => {
                neuralDensity = parseInt(e.target.value);
                neuralVal.innerText = neuralDensity + "%";
            });

            refreshBtn.addEventListener('click', () => {
                // 随机一个新的偏移种子
                lineSeed = Math.floor(Math.random() * particleCount);
                updateLines(); // 强制更新
            });

            // 7. 形状变形
            const shapeSlider = document.getElementById('shape-slider');
            const shapeVal = document.getElementById('shape-val');
            shapeSlider.addEventListener('input', (e) => {
                shapeMorph = parseFloat(e.target.value);
                if(material) material.uniforms.uShape.value = shapeMorph;

                // 更新显示文本
                let txt = "Glow";
                if (shapeMorph > 0.5 && shapeMorph <= 1.5) txt = "Diamond";
                else if (shapeMorph > 1.5 && shapeMorph <= 2.5) txt = "Square";
                else if (shapeMorph > 2.5) txt = "Ring";
                shapeVal.innerText = txt;
            });
        }

        function logSystem(msg) {
            const log = document.getElementById('ai-log');
            log.innerHTML += `\n[SYS] ${msg}`;
            log.scrollTop = log.scrollHeight;
        }

        // --- 本地过程化生成模块 ---
        // ... existing procedural functions ...
        
        // 预设点击处理
        function usePreset(name) {
            document.getElementById('ai-input').value = name;
            triggerAI();
        }

        function triggerAI() {
            const input = document.getElementById('ai-input');
            const btn = document.getElementById('ai-btn');
            const log = document.getElementById('ai-log');
            const prompt = input.value.trim().toLowerCase();

            if (!prompt) return;

            input.disabled = true;
            btn.disabled = true;
            log.innerHTML += `\n>> PARSING: "${prompt}"...`;
            log.scrollTop = log.scrollHeight;

            // 模拟计算延迟
            setTimeout(() => {
                try {
                    let newPos = [];
                    
                    // 关键词匹配算法
                    if (prompt.includes('galaxy') || prompt.includes('spiral')) {
                        newPos = getProceduralGalaxy();
                    } else if (prompt.includes('dna') || prompt.includes('helix')) {
                        newPos = getProceduralDNA();
                    } else if (prompt.includes('tornado') || prompt.includes('storm')) {
                        newPos = getProceduralTornado();
                    } else if (prompt.includes('pyramid')) {
                        newPos = getProceduralPyramid();
                    } else if (prompt.includes('atom') || prompt.includes('nucleus')) {
                        newPos = getProceduralAtom();
                    } else if (prompt.includes('matrix') || prompt.includes('grid') || prompt.includes('cube')) {
                        newPos = getProceduralCube();
                    } else {
                        // 默认回退到混沌模式
                         newPos = getProceduralAbstract();
                         logSystem(`Unknown pattern. Generating Abstract Chaos.`);
                    }
                    
                    log.innerHTML += `\n>> CONSTRUCTING GEOMETRY...`;
                    log.scrollTop = log.scrollHeight;

                    transformToCustom(newPos, prompt.toUpperCase());
                    
                    // 生成一些随机的系统日志
                    const lores = [
                         "Geometry synthesized locally.",
                         "Quantum resonance stable.",
                         "Structure compiled from void data.",
                         "Local reality overridden.",
                         "Entropy reshaped successfully."
                    ];
                    logSystem(lores[Math.floor(Math.random() * lores.length)]);

                } catch (error) {
                    console.error(error);
                    log.innerHTML += `\n[ERROR] GENERATION FAILED.`;
                } finally {
                    input.disabled = false;
                    btn.disabled = false;
                    input.value = '';
                    input.focus();
                }
            }, 500);
        }

        // --- 过程化生成算法 (带随机项) ---

        function getProceduralGalaxy() {
            const arr = [];
            // 随机参数：旋臂数量(3-6)，紧密度，偏移
            const arms = Math.floor(rand(3, 7));
            const spin = rand(0.1, 0.3);
            const spread = rand(0.5, 1.5);
            
            for (let i = 0; i < particleCount; i++) {
                // 随机分布
                const t = Math.random(); // 0 to 1 along arm
                const armIndex = i % arms;
                const angle = t * Math.PI * 2 * arms * spin + (armIndex * Math.PI * 2 / arms);
                const r = 800 * t + 50;
                
                // 增加随机噪声
                const noiseX = (Math.random() - 0.5) * 200 * t * spread;
                const noiseY = (Math.random() - 0.5) * 200 * t * spread;
                const noiseZ = (Math.random() - 0.5) * 150 * (1 - t); // 中心厚，边缘薄

                arr.push(
                    Math.cos(angle) * r + noiseX,
                    Math.sin(angle) * r + noiseY,
                    noiseZ
                );
            }
            return arr;
        }

        function getProceduralDNA() {
            const arr = [];
            // 随机参数：螺旋速度，半径，长度
            const twist = rand(0.05, 0.15);
            const radius = rand(100, 250);
            const length = rand(1000, 1800);
            
            for (let i = 0; i < particleCount; i++) {
                const layer = i % 2 === 0 ? 1 : -1; // 双链
                const t = (i / particleCount) * length - length/2;
                const angle = t * twist;
                
                const noise = (Math.random() - 0.5) * 20;
                
                arr.push(
                    Math.cos(angle + (layer * Math.PI)) * radius + noise,
                    Math.sin(angle + (layer * Math.PI)) * radius + noise,
                    t + (Math.random() - 0.5) * 50
                );
            }
            return arr;
        }

        function getProceduralTornado() {
            const arr = [];
            // 随机：高度，顶端半径倍率
            const height = rand(800, 1200);
            const topSpread = rand(2, 5);
            
            for (let i = 0; i < particleCount; i++) {
                const h = (i / particleCount) * height - height/2;
                const t = (h + height/2) / height; // 0 (bottom) to 1 (top)
                const r = 20 + t * 400 * topSpread; // 底部窄，顶部宽
                const angle = h * 0.1;
                
                const noise = (Math.random()-0.5) * 50 * t;
                
                arr.push(
                    Math.cos(angle) * r + noise,
                    h + (Math.random()-0.5) * 20,
                    Math.sin(angle) * r + noise
                );
            }
            return arr;
        }

        function getProceduralPyramid() {
            const arr = [];
            const baseSize = rand(600, 1000);
            
            for (let i = 0; i < particleCount; i++) {
                // 随机点在金字塔体积内
                // x, z range from -size to size based on y height
                const y = (Math.random() - 0.5) * baseSize; // Height
                const scale = 1 - (y + baseSize/2) / baseSize; // 1 at bottom, 0 at top
                
                // 增加一些边缘聚集效果
                const edge = Math.random() > 0.8;
                let x, z;
                
                if (edge) {
                    // 边缘线条
                    x = (Math.random() > 0.5 ? 1 : -1) * (baseSize/2 * scale);
                    z = (Math.random() - 0.5) * baseSize * scale;
                    if (Math.random() > 0.5) [x, z] = [z, x];
                } else {
                    // 内部填充
                    x = (Math.random() - 0.5) * baseSize * scale;
                    z = (Math.random() - 0.5) * baseSize * scale;
                }

                arr.push(x, y, z);
            }
            return arr;
        }

        function getProceduralAtom() {
            const arr = [];
            const nucleusSize = rand(50, 100);
            const orbits = Math.floor(rand(3, 6));
            
            for (let i = 0; i < particleCount; i++) {
                if (i < particleCount * 0.2) {
                    // 核心 (Nucleus)
                    const r = Math.random() * nucleusSize;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    arr.push(
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    );
                } else {
                    // 电子轨道
                    const orbitIdx = Math.floor(Math.random() * orbits);
                    const angleOffset = (Math.PI / orbits) * orbitIdx;
                    const t = Math.random() * Math.PI * 2;
                    const radius = rand(300, 600);
                    
                    // 旋转轨道平面
                    const x0 = radius * Math.cos(t);
                    const y0 = radius * Math.sin(t) * 0.3; // 扁平化
                    const z0 = (Math.random() - 0.5) * 20; // 轨道厚度
                    
                    // 绕随机轴旋转
                    const cosA = Math.cos(angleOffset * Math.PI); // 增加旋转随机性
                    const sinA = Math.sin(angleOffset * Math.PI);
                    
                    arr.push(
                        x0 * Math.cos(angleOffset) - y0 * Math.sin(angleOffset), // 简化旋转
                        x0 * Math.sin(angleOffset) + y0 * Math.cos(angleOffset),
                        z0 + x0 * Math.sin(angleOffset * 2) // 添加Z轴倾斜
                    );
                }
            }
            return arr;
        }

        function getProceduralCube() {
            const arr = [];
            const size = rand(600, 900);
            
            for (let i = 0; i < particleCount; i++) {
                // 随机填充立方体，带网格感
                let x = (Math.random() - 0.5) * size;
                let y = (Math.random() - 0.5) * size;
                let z = (Math.random() - 0.5) * size;
                
                // 量子化坐标以形成网格
                const grid = 50;
                x = Math.round(x / grid) * grid;
                y = Math.round(y / grid) * grid;
                z = Math.round(z / grid) * grid;
                
                // 随机空缺
                if (Math.random() > 0.8) {
                    x *= 2; y *= 2; z *= 2; // 外部飞散点
                }
                
                arr.push(x, y, z);
            }
            return arr;
        }

        function getProceduralAbstract() {
            const arr = [];
            // 随机参数生成奇怪的数学形状
            const a = rand(0.01, 0.1);
            const b = rand(0.01, 0.1);
            const c = rand(0.01, 0.1);
            const scale = rand(300, 600);
            
            for (let i = 0; i < particleCount; i++) {
                const ix = i * a;
                const iy = i * b;
                const iz = i * c;
                
                arr.push(
                    Math.sin(ix) * Math.cos(iy) * scale,
                    Math.cos(ix) * Math.sin(iz) * scale,
                    Math.sin(iy) * Math.cos(iz) * scale
                );
            }
            return arr;
        }

        // --- 经典图形生成算法 ---

        function getUniverseLayout() {
            const arr = [];
            for (let i = 0; i < particleCount; i++) {
                const r = 800 + Math.random() * 800;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                arr.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            }
            return arr;
        }

        function getHeartLayout() {
            const arr = [];
            for (let i = 0; i < particleCount; i++) {
                const t = Math.random() * Math.PI * 2;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                let z = (Math.random() - 0.5) * 10; 
                const scale = 25; 
                const r = scale * (Math.random() * 0.2 + 0.8);
                arr.push(x * r, y * r, z * scale * 4 * Math.random()); 
            }
            return arr;
        }

        function getMobiusLayout() {
            const arr = [];
            for (let i = 0; i < particleCount; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = (Math.random() * 2) - 1;
                const radius = 350;
                const stripWidth = 150;
                arr.push(
                    (radius + v * stripWidth / 2 * Math.cos(u / 2)) * Math.cos(u),
                    (radius + v * stripWidth / 2 * Math.cos(u / 2)) * Math.sin(u),
                    v * stripWidth / 2 * Math.sin(u / 2)
                );
            }
            return arr;
        }

        function getFractalLayout() {
            const arr = [];
            const size = 600;
            const v = [{x: size, y: size, z: size}, {x: -size, y: -size, z: size}, {x: -size, y: size, z: -size}, {x: size, y: -size, z: -size}];
            let currentP = {x: 0, y: 0, z: 0};
            for (let i = 0; i < particleCount; i++) {
                const targetV = v[Math.floor(Math.random() * 4)];
                currentP.x = (currentP.x + targetV.x) / 2;
                currentP.y = (currentP.y + targetV.y) / 2;
                currentP.z = (currentP.z + targetV.z) / 2;
                if (i > 20) arr.push(currentP.x, currentP.y, currentP.z);
                else arr.push(0,0,0);
            }
            return arr;
        }

        function getPenroseLayout() {
            const arr = [];
            for (let i = 0; i < particleCount; i++) {
                const u = (i / particleCount) * 20 * Math.PI;
                const radius = i / particleCount * 500;
                arr.push(radius * Math.cos(u), radius * Math.sin(u) - 200, i / particleCount * 600 - 300);
            }
            return arr;
        }

        // --- 颜色生成 ---
        function getColors(type) {
            const arr = [];
            const c = new THREE.Color();
            for (let i = 0; i < particleCount; i++) {
                if (type === 'universe') c.setHSL(0.6 + Math.random() * 0.1, 0.8, 0.6);
                else if (type === 'heart') c.setHSL(0.95 + Math.random() * 0.1, 0.9, 0.5);
                else if (type === 'mobius') c.setHSL(0.5 + Math.random() * 0.2, 0.8, 0.5);
                else if (type === 'fractal') c.setHSL(0.1 + Math.random() * 0.1, 1.0, 0.6);
                else if (type === 'penrose') c.setHSL(0.75 + Math.random() * 0.2, 0.5, 0.8);
                else c.setHSL(Math.random(), 0.8, 0.6); 
                arr.push(c.r, c.g, c.b);
            }
            return arr;
        }

        // --- 变换逻辑 ---
        function transformTo(shape) {
            if (currentShape === shape) return;
            document.getElementById('ai-input').value = "";
            customShapeCode = null; 
            
            let nextPos;
            switch (shape) {
                case 'universe': nextPos = getUniverseLayout(); break;
                case 'heart': nextPos = getHeartLayout(); break;
                case 'mobius': nextPos = getMobiusLayout(); break;
                case 'fractal': nextPos = getFractalLayout(); break;
                case 'penrose': nextPos = getPenroseLayout(); break;
                default: return;
            }
            
            const logs = {
                'universe': "Resetting entropy to cosmic background levels.",
                'heart': "Bio-digital rhythm detected. Synchronizing...",
                'mobius': "Topological loop initiated. Infinite regression.",
                'fractal': "Recursive geometry loaded. Self-similarity: 100%.",
                'penrose': "Non-euclidean geometry detected. Reality distortion active."
            };
            logSystem(logs[shape]);

            executeTransition(nextPos, shape, getColors(shape));
        }

        function transformToCustom(posArray, name) {
            executeTransition(posArray, 'custom', getColors('ai'));
            document.querySelectorAll('.sci-fi-btn').forEach(btn => btn.classList.remove('active'));
        }

        function executeTransition(nextPos, shapeName, nextColors) {
            currentShape = shapeName;
            if(shapeName !== 'custom') {
                document.querySelectorAll('.sci-fi-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if(btn.innerText.toLowerCase().includes(shapeName)) btn.classList.add('active');
                });
            }

            if (currentTween) currentTween.stop();

            const startPositions = Float32Array.from(geometry.attributes.position.array);
            const startColors = Float32Array.from(geometry.attributes.color.array);

            transitionParams.val = 0;

            currentTween = new TWEEN.Tween(transitionParams)
                .to({ val: 1 }, 2000)
                .easing(TWEEN.Easing.Exponential.InOut)
                .onUpdate(() => {
                    const alpha = transitionParams.val;
                    const posAttr = geometry.attributes.position;
                    const colAttr = geometry.attributes.color;

                    const count = Math.min(particleCount, posAttr.count);

                    for (let i = 0; i < count; i++) {
                        const idx = i * 3;
                        posAttr.array[idx] = startPositions[idx] + (nextPos[idx] - startPositions[idx]) * alpha;
                        posAttr.array[idx+1] = startPositions[idx+1] + (nextPos[idx+1] - startPositions[idx+1]) * alpha;
                        posAttr.array[idx+2] = startPositions[idx+2] + (nextPos[idx+2] - startPositions[idx+2]) * alpha;

                        colAttr.array[idx] = startColors[idx] + (nextColors[idx] - startColors[idx]) * alpha;
                        colAttr.array[idx+1] = startColors[idx+1] + (nextColors[idx+1] - startColors[idx+1]) * alpha;
                        colAttr.array[idx+2] = startColors[idx+2] + (nextColors[idx+2] - startColors[idx+2]) * alpha;
                    }
                    
                    posAttr.needsUpdate = true;
                    colAttr.needsUpdate = true;
                })
                .start();
        }

        // --- 渲染 ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now();
            frames++;
            if (time >= lastTime + 1000) {
                fpsCounter.innerText = Math.round((frames * 1000) / (time - lastTime));
                lastTime = time;
                frames = 0;
            }

            TWEEN.update();
            
            // 更新连线
            if (neuralDensity > 0) {
                updateLines();
            } else if (linesMesh && linesMesh.visible) {
                // 如果密度为0但网格还可见，隐藏它
                const positions = linesGeometry.attributes.position.array;
                for (let i = 0; i < positions.length; i++) positions[i] = 0;
                linesGeometry.attributes.position.needsUpdate = true;
            }

            const rotationSpeed = 0.001 * simSpeed;
            let chaosMultiplier = (1.0 - stability) * 5;

            particles.rotation.y += rotationSpeed * (1 + chaosMultiplier * Math.random());
            particles.rotation.z += rotationSpeed * 0.2 * (1 - chaosMultiplier * Math.random());

            if (stability < 0.95) {
                const shakeIntensity = (1.0 - stability) * 10;
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
            }

            camera.position.x += (mouseX - camera.position.x) * 0.05 * simSpeed;
            camera.position.y += (-mouseY - camera.position.y) * 0.05 * simSpeed;
            camera.lookAt(scene.position);

            renderer.autoClearColor = false;
            renderer.clear(); 
            renderer.render(scene, camera);
        }

        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - windowHalfX) * 1;
            mouseY = (event.clientY - windowHalfY) * 1;
        }

        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // generateSprite 已被 Shader 替代，不再需要
        
        window.transformTo = transformTo;
        window.triggerAI = triggerAI;
        window.usePreset = usePreset;
    </script>
</body>
</html>
