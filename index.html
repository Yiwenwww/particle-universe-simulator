<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Particle Universe + Math Core</title>
    <style>
        /* --- 全局设置 --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; }
        canvas { display: block; }

        /* --- UI 容器 --- */
        #hologram-ui {
            position: absolute; top: 20px; left: 20px; width: 380px;
            pointer-events: auto; 
            z-index: 10; max-height: 90vh;
            overflow-y: auto; 
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: #0ff rgba(0, 20, 40, 0.5);
        }

        /* --- 自定义滚动条样式 --- */
        #hologram-ui::-webkit-scrollbar { width: 6px; display: block; }
        #hologram-ui::-webkit-scrollbar-track { background: rgba(0, 20, 40, 0.5); border-left: 1px solid rgba(0, 255, 255, 0.1); }
        #hologram-ui::-webkit-scrollbar-thumb { background: rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.5); border-radius: 3px; }
        #hologram-ui::-webkit-scrollbar-thumb:hover { background: rgba(0, 255, 255, 0.6); box-shadow: 0 0 8px #0ff; }

        /* 面板框架 */
        .panel-frame {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid rgba(0, 255, 255, 0.8);
            padding: 15px; backdrop-filter: blur(6px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            position: relative; overflow: hidden; pointer-events: auto;
            margin-bottom: 10px; transition: max-height 0.3s ease;
        }
        .panel-frame::before {
            content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(0, 255, 255, 0.5); animation: scan 3s linear infinite;
            opacity: 0.3; pointer-events: none;
        }
        @keyframes scan { 0% { top: 0; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }

        h1 {
            color: #0ff; font-size: 16px; margin: 0 0 12px 0; text-transform: uppercase;
            letter-spacing: 2px; text-shadow: 0 0 5px #0ff; border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 5px; display: flex; justify-content: space-between; align-items: center;
        }
        .fps-badge { font-size: 12px; background: rgba(0, 255, 255, 0.2); padding: 2px 6px; border-radius: 2px; }

        /* --- 控件样式 --- */
        .control-section { margin-bottom: 10px; border-bottom: 1px dashed rgba(0,255,255,0.2); padding-bottom: 5px; }
        .section-title {
            color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 8px; opacity: 0.9;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
            background: rgba(0, 255, 255, 0.05); padding: 4px; border-radius: 2px; transition: background 0.2s;
        }
        .section-title:hover { background: rgba(0, 255, 255, 0.15); }
        .section-title::after { content: '▼'; font-size: 10px; margin-left: 5px; transition: transform 0.3s; }
        .control-section.collapsed .section-title::after { transform: rotate(-90deg); }
        .section-content { max-height: 800px; overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.3s ease-out; opacity: 1; }
        .control-section.collapsed .section-content { max-height: 0; opacity: 0; }

        .control-row { margin-bottom: 8px; }
        .control-header { display: flex; justify-content: space-between; align-items: center; color: rgba(0, 255, 255, 0.8); font-size: 10px; margin-bottom: 2px; }
        .control-value { color: #fff; font-weight: bold; }

        .refresh-btn {
            background: rgba(0, 0, 0, 0.5); border: 1px solid #0ff; color: #0ff;
            border-radius: 50%; width: 16px; height: 16px; display: flex;
            justify-content: center; align-items: center; cursor: pointer; font-size: 10px; margin-left: 6px; transition: all 0.2s;
        }
        .refresh-btn:hover { background: #0ff; color: #000; transform: rotate(180deg); }

        .toggle-switch {
            position: relative; width: 30px; height: 14px; background: rgba(0, 255, 255, 0.2);
            border-radius: 7px; cursor: pointer; border: 1px solid rgba(0, 255, 255, 0.4);
        }
        .toggle-switch::after {
            content: ''; position: absolute; left: 1px; top: 1px; width: 10px; height: 10px;
            background: #0ff; border-radius: 50%; transition: all 0.3s; box-shadow: 0 0 5px #0ff;
        }
        .toggle-switch.active { background: rgba(0, 255, 255, 0.5); }
        .toggle-switch.active::after { left: 17px; background: #fff; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.4); }
        input[type=range]::-webkit-slider-thumb { height: 12px; width: 8px; border: 1px solid #0ff; background: #000; cursor: pointer; -webkit-appearance: none; margin-top: -5px; box-shadow: 0 0 5px #0ff; transition: background 0.2s; }
        input[type=range]::-webkit-slider-thumb:hover { background: #0ff; }

        .slider-red::-webkit-slider-runnable-track { background: rgba(255,0,0,0.3); border-color: rgba(255,0,0,0.5); }
        .slider-red::-webkit-slider-thumb { border-color: #f00; box-shadow: 0 0 5px #f00; }
        .slider-green::-webkit-slider-runnable-track { background: rgba(0,255,0,0.3); border-color: rgba(0,255,0,0.5); }
        .slider-green::-webkit-slider-thumb { border-color: #0f0; box-shadow: 0 0 5px #0f0; }
        .slider-blue::-webkit-slider-runnable-track { background: rgba(0,0,255,0.3); border-color: rgba(0,0,255,0.5); }
        .slider-blue::-webkit-slider-thumb { border-color: #00f; box-shadow: 0 0 5px #00f; }

        .terminal-input-group { display: flex; gap: 5px; margin-bottom: 5px; }
        #ai-input { background: rgba(0,0,0,0.5); border: 1px solid #0ff; color: #0ff; font-family: inherit; font-size: 12px; padding: 8px; width: 100%; outline: none; }
        #ai-btn { background: rgba(0,255,255,0.2); border: 1px solid #0ff; color: #0ff; cursor: pointer; font-weight: bold; padding: 0 10px; font-size: 16px; }
        #ai-btn:hover { background: #0ff; color: #000; }

        .math-tags { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
        .math-tag { font-size: 9px; color: rgba(0,255,255,0.7); border: 1px solid rgba(0,255,255,0.3); padding: 4px 8px; cursor: pointer; transition: all 0.2s; background: rgba(0,0,0,0.3); user-select: none; text-transform: uppercase; flex-grow: 1; text-align: center; }
        .math-tag:hover { background: rgba(0,255,255,0.2); border-color: #0ff; color: #fff; }
        .math-tag.selected { background: rgba(0, 255, 255, 0.6); color: #000; border-color: #fff; }
        .tag-category { width: 100%; font-size: 9px; color: #0ff; margin: 5px 0 2px 0; opacity: 0.7; border-bottom: 1px solid rgba(0,255,255,0.2); }

        .ai-log { font-size: 10px; color: #0f0; height: 50px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 5px; border: 1px solid rgba(0,255,0,0.2); white-space: pre-wrap; line-height: 1.4; }
        .ai-log::-webkit-scrollbar { width: 4px; } .ai-log::-webkit-scrollbar-track { background: #000; } .ai-log::-webkit-scrollbar-thumb { background: #0ff; }

        /* 音乐 & 可视化样式 */
        .sci-fi-file-input { font-size: 10px; color: rgba(0, 255, 255, 0.8); width: 100%; background: rgba(0, 0, 0, 0.3); border: 1px dashed rgba(0, 255, 255, 0.3); padding: 5px; cursor: pointer; }
        .sci-fi-file-input::-webkit-file-upload-button { background: rgba(0, 255, 255, 0.2); border: 1px solid #0ff; color: #0ff; padding: 2px 8px; cursor: pointer; font-family: inherit; margin-right: 10px; }
        .sci-fi-btn-small { background: rgba(0, 0, 0, 0.5); border: 1px solid #0ff; color: #0ff; padding: 4px 12px; font-family: inherit; font-size: 10px; cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
        .sci-fi-btn-small:hover { background: #0ff; color: #000; }
        .sci-fi-btn-small.active { background: #0ff; color: #000; box-shadow: 0 0 10px #0ff; }
        
        .viz-canvas { width: 100%; height: 40px; background: rgba(0, 20, 40, 0.5); border: 1px solid rgba(0, 255, 255, 0.2); margin-top: 5px; display: block; }
        
        .mod-bar-container { margin-top: 4px; width: 100%; height: 4px; background: rgba(0,255,255,0.1); position: relative; }
        .mod-bar { height: 100%; background: #0ff; width: 0%; transition: width 0.1s; box-shadow: 0 0 5px #0ff; }

        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; color: #0ff; z-index: 100; flex-direction: column; }
        .loader-bar { width: 200px; height: 2px; background: #333; margin-top: 10px; position: relative; }
        .loader-progress { position: absolute; left: 0; top: 0; height: 100%; background: #0ff; width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #0ff; }
        
        #gesture-hint {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            text-shadow: 0 0 10px #0ff; border: 1px solid #0ff; padding: 10px; background: rgba(0,0,0,0.7);
            z-index: 20; text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader">
        <div>INITIALIZING MATH CORE...</div>
        <div class="loader-bar"><div class="loader-progress" id="progress"></div></div>
    </div>
    
    <div id="gesture-hint">
        <div>XY MODULATION ACTIVE</div>
        <div style="font-size:10px; color:#aaa;">X: FILTER | Y: RIPPLE | CLICK: DISTORT</div>
    </div>
    
    <div id="hologram-ui">
        <div class="panel-frame">
            <h1>
                SYSTEM STATUS
                <span class="fps-badge"><span id="fps-counter">60</span> FPS</span>
            </h1>
            
            <!-- 模拟控制 -->
            <div class="control-section">
                <div class="section-title" onclick="toggleSection(this)">>> SIMULATION CORE</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>PARTICLE DENSITY</span><span class="control-value" id="particle-val">20,000</span></div>
                        <input type="range" id="particle-slider" min="5000" max="50000" step="1000" value="20000">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>TIME DILATION</span><span class="control-value" id="speed-val">1.0x</span></div>
                        <input type="range" id="speed-slider" min="0" max="3" step="0.1" value="1.0">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>FIELD STABILITY</span><span class="control-value" id="stability-val" style="color: #0f0;">100%</span></div>
                        <input type="range" id="stability-slider" min="0" max="100" step="1" value="100">
                    </div>
                </div>
            </div>

            <!-- 动态控制 -->
            <div class="control-section">
                <div class="section-title" onclick="toggleSection(this)">>> DYNAMICS & MOTION</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>AUTO ROTATION</span><div class="toggle-switch active" id="toggle-rotate"></div></div>
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>PULSE INTENSITY</span><span class="control-value" id="pulse-val">0.0</span></div>
                        <input type="range" id="pulse-slider" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>

            <!-- 音乐控制模块 -->
            <div class="control-section collapsed">
                <div class="section-title" onclick="toggleSection(this)">>> SONIC RESONANCE FIELD</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>AUDIO SOURCE</span></div>
                        <input type="file" id="audio-file" accept="audio/*" class="sci-fi-file-input">
                    </div>
                    <div class="control-row" style="display:flex; align-items:center; gap:10px;">
                        <button id="audio-play-btn" class="sci-fi-btn-small">PLAY</button>
                        <button id="file-gesture-btn" class="sci-fi-btn-small" title="Pinch Music (XY Pad)">XY MOD</button>
                        <div style="flex:1">
                            <div class="control-header" style="margin-bottom:0;"><span>VOL</span></div>
                            <input type="range" id="audio-volume" min="0" max="1" step="0.01" value="0.5">
                        </div>
                    </div>
                    
                    <!-- 频段灵敏度 -->
                    <div class="control-row" style="margin-top:10px;">
                        <div class="control-header"><span>BASS SENSITIVITY</span><span class="control-value" id="bass-sens-val">1.0</span></div>
                        <input type="range" id="bass-sens-slider" min="0" max="3" step="0.1" value="1.0">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>TREBLE SENSITIVITY</span><span class="control-value" id="treble-sens-val">1.0</span></div>
                        <input type="range" id="treble-sens-slider" min="0" max="3" step="0.1" value="1.0">
                    </div>

                    <!-- 调制监视器 -->
                    <div class="control-row" style="margin-top:10px;">
                        <div class="control-header"><span>MODULATION MONITOR (X/Y)</span></div>
                        <div class="control-header" style="font-size:9px; color:#aaa;">CUTOFF / BRIGHTNESS (X)</div>
                        <div class="mod-bar-container"><div id="mod-cutoff-bar" class="mod-bar"></div></div>
                        <div class="control-header" style="font-size:9px; color:#aaa; margin-top:4px;">RES / RIPPLE (Y)</div>
                        <div class="mod-bar-container"><div id="mod-res-bar" class="mod-bar" style="background:#ff0; box-shadow:0 0 5px #ff0;"></div></div>
                    </div>

                    <canvas id="file-visualizer" class="viz-canvas" width="340" height="40"></canvas>
                </div>
            </div>

            <!-- 外观控制 -->
            <div class="control-section">
                <div class="section-title" onclick="toggleSection(this)">>> PARTICLE APPEARANCE</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>PARTICLE SIZE</span><span class="control-value" id="size-val">6.0</span></div>
                        <input type="range" id="size-slider" min="1" max="20" step="0.1" value="6.0">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>SPECTRAL FILTER (RGB)</span><span class="control-value" id="rgb-val">255, 255, 255</span></div>
                        <input type="range" class="slider-red" id="slider-r" min="0" max="255" value="255" style="margin-bottom:4px;">
                        <input type="range" class="slider-green" id="slider-g" min="0" max="255" value="255" style="margin-bottom:4px;">
                        <input type="range" class="slider-blue" id="slider-b" min="0" max="255" value="255">
                    </div>
                    <div class="control-row">
                        <div class="control-header">
                            <span>NEURAL DENSITY (LINES)</span>
                            <div style="display:flex; align-items:center;">
                                <span class="control-value" id="neural-val" style="margin-right:5px;">0%</span>
                                <div class="refresh-btn" id="btn-refresh-lines" title="Randomize Connections">↻</div>
                            </div>
                        </div>
                        <input type="range" id="neural-slider" min="0" max="100" step="1" value="0">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>SHAPE MORPH</span><span class="control-value" id="shape-val">Glow</span></div>
                        <input type="range" id="shape-slider" min="0" max="3" step="0.01" value="0">
                    </div>
                </div>
            </div>
            
            <!-- AI 终端 / 数学生成区 -->
            <div class="control-section" style="border:none; margin-bottom:0;">
                <div class="section-title" onclick="toggleSection(this)">>> DIMENSIONAL RECONSTRUCTOR</div>
                <div class="section-content">
                    
                    <!-- 数学模型面板 -->
                    <div class="section-title" style="margin-top:10px; font-size:10px; background:none; pointer-events:none;">>> MATHEMATICAL MODELS</div>
                    <div class="tag-category">GEOMETRY</div>
                    <div class="math-tags">
                        <div class="math-tag selected" onclick="selectShape('Universe')">Universe</div>
                        <div class="math-tag" onclick="selectShape('Heart')">Heart</div>
                        <div class="math-tag" onclick="selectShape('Mobius')">Mobius</div>
                        <div class="math-tag" onclick="selectShape('Penrose')">Penrose</div>
                        <div class="math-tag" onclick="selectShape('Tornado')">Tornado</div>
                    </div>
                    
                    <div class="tag-category">CHAOS ATTRACTORS</div>
                    <div class="math-tags">
                        <div class="math-tag" onclick="selectShape('Lorenz')">Lorenz</div>
                        <div class="math-tag" onclick="selectShape('Aizawa')">Aizawa</div>
                        <div class="math-tag" onclick="selectShape('Thomas')">Thomas</div>
                        <div class="math-tag" onclick="selectShape('Halvorsen')">Halvorsen</div>
                        <div class="math-tag" onclick="selectShape('Dadras')">Dadras</div>
                    </div>

                    <div class="tag-category">FRACTALS & STRUCTURES</div>
                    <div class="math-tags">
                        <div class="math-tag" onclick="selectShape('Sierpinski')">Sierpinski</div>
                        <div class="math-tag" onclick="selectShape('Mandelbulb')">Mandelbulb</div>
                        <div class="math-tag" onclick="selectShape('DNA')">DNA</div>
                        <div class="math-tag" onclick="selectShape('Atom')">Atom</div>
                    </div>

                    <div class="ai-log" id="ai-log">
                        [SYSTEM] Math Core loaded.
                        [INFO] Select a mathematical model to reconstruct.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 3D Variables ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let linesMesh, linesGeometry;
        let connections = [];
        let particleCount = 20000;
        const maxLines = 10000;
        
        // --- Control Variables ---
        let simSpeed = 1.0;
        let stability = 1.0;
        let particleSize = 6.0;
        let neuralDensity = 0;
        let shapeMorph = 0.0;
        let activeMixShapes = new Set();
        let autoRotate = true;
        let pulseIntensity = 0.0;
        let colorR = 1, colorG = 1, colorB = 1;
        let currentShape = 'universe';
        let currentTween = null;
        const transitionParams = { val: 1 };
        
        // --- Audio Settings ---
        let bassSensitivity = 1.0;
        let trebleSensitivity = 1.0;
        let isGestureActive = false;
        let isPinching = false;
        let normMouseX = 0.5, normMouseY = 0.0; 

        // --- Audio: File Player Variables ---
        let fileAudioCtx, fileAnalyser, fileSource;
        let fileGainNode, fileFilterNode, fileDistortionNode; 
        let isFilePlaying = false;
        let fileFreqData, fileTimeData;
        const fileVizCanvas = document.getElementById('file-visualizer');
        const fileVizCtx = fileVizCanvas.getContext('2d');

        let lastTime = performance.now();
        let frames = 0;
        const fpsCounter = document.getElementById('fps-counter');
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        const rand = (min, max) => Math.random() * (max - min) + min;

        // --- MATHEMATICAL GENERATORS (Procedural with Random Perturbation) ---
        
        // 1. CHAOS ATTRACTORS
        // Helper to integrate ODEs
        function generateAttractor(odeFunc, scale, steps, dt) {
            const arr = [];
            let x = 0.1, y = 0.1, z = 0.1; // Initial conditions
            // Pre-warm
            for(let i=0; i<100; i++) { const d = odeFunc(x,y,z); x+=d.x*dt; y+=d.y*dt; z+=d.z*dt; }
            
            for(let i=0; i<particleCount; i++) {
                const d = odeFunc(x,y,z);
                x += d.x * dt;
                y += d.y * dt;
                z += d.z * dt;
                
                // Add random perturbation (Noise)
                const noise = 0.5; // Strength
                arr.push(
                    x * scale + (Math.random()-0.5)*noise, 
                    y * scale + (Math.random()-0.5)*noise, 
                    z * scale + (Math.random()-0.5)*noise
                );
                
                // Reset if trails wander too far or for multiple trails (simplified single trail here)
            }
            return arr;
        }

        function getLorenz() {
            const sigma = 10, rho = 28, beta = 8/3;
            return generateAttractor((x,y,z) => ({
                x: sigma * (y - x),
                y: x * (rho - z) - y,
                z: x * y - beta * z
            }), 15, particleCount, 0.005);
        }

        function getAizawa() {
            const a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1;
            return generateAttractor((x,y,z) => ({
                x: (z - b) * x - d * y,
                y: d * x + (z - b) * y,
                z: c + a * z - z * z * z / 3 - (x * x + y * y) * (1 + e * z) + f * z * x * x * x 
            }), 150, particleCount, 0.01);
        }

        function getThomas() {
            const b = 0.208186;
            return generateAttractor((x,y,z) => ({
                x: -b * x + Math.sin(y),
                y: -b * y + Math.sin(z),
                z: -b * z + Math.sin(x)
            }), 100, particleCount, 0.05);
        }

        function getHalvorsen() {
            const a = 1.4;
            return generateAttractor((x,y,z) => ({
                x: -a * x - 4 * y - 4 * z - y * y,
                y: -a * y - 4 * z - 4 * x - z * z,
                z: -a * z - 4 * x - 4 * y - x * x
            }), 40, particleCount, 0.005);
        }

        function getDadras() {
            const p=3, q=2.7, r=1.7, s=2, e=9;
            return generateAttractor((x,y,z) => ({
                x: y - p * x + q * y * z,
                y: r * y - x * z + z,
                z: s * x * y - e * z
            }), 40, particleCount, 0.005);
        }

        // 2. FRACTALS & GEOMETRY
        function getSierpinski() {
            const arr = [];
            // 3D Sierpinski Tetrahedron (Chaos Game approximation)
            const corners = [
                {x: 400, y: -300, z: 400}, {x: -400, y: -300, z: 400},
                {x: 0, y: -300, z: -400}, {x: 0, y: 400, z: 0}
            ];
            let cx = 0, cy = 0, cz = 0;
            for(let i=0; i<particleCount; i++) {
                const target = corners[Math.floor(Math.random() * 4)];
                cx = (cx + target.x) / 2;
                cy = (cy + target.y) / 2;
                cz = (cz + target.z) / 2;
                // Add noise
                arr.push(cx + (Math.random()-0.5)*5, cy + (Math.random()-0.5)*5, cz + (Math.random()-0.5)*5);
            }
            return arr;
        }

        function getMandelbulb() {
            const arr = [];
            const dim = 128; // grid density
            // Approximate a cloud
            for(let i=0; i<particleCount; i++) {
                // Rejection sampling or random polar coords
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 400 * Math.pow(Math.random(), 1/3); // Uniform sphere
                
                // Deform sphere towards Mandelbulb-ish shape (Power 8)
                // Just a visual approximation for particle cloud without raymarching
                const scale = 1 + 0.5 * Math.sin(theta*8) * Math.cos(phi*8);
                
                arr.push(
                    r * Math.sin(phi) * Math.cos(theta) * scale,
                    r * Math.sin(phi) * Math.sin(theta) * scale,
                    r * Math.cos(phi) * scale
                );
            }
            return arr;
        }

        // 3. STANDARD SHAPES (Refined)
        function getUniverse() { return getProceduralGalaxy(); } // Default
        function getHeart() { const arr=[]; for(let i=0;i<particleCount;i++){ const t=Math.random()*Math.PI*2; let x=16*Math.pow(Math.sin(t),3); let y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); let z=(Math.random()-0.5)*10; const s=25; const r=s*(Math.random()*0.2+0.8); arr.push(x*r, y*r, z*s*4*Math.random()); } return arr; }
        function getMobius() { const arr=[]; for(let i=0;i<particleCount;i++){ const u=Math.random()*Math.PI*2; const v=(Math.random()*2)-1; const r=350; const sw=150; arr.push((r+v*sw/2*Math.cos(u/2))*Math.cos(u), (r+v*sw/2*Math.cos(u/2))*Math.sin(u), v*sw/2*Math.sin(u/2)); } return arr; }
        function getPenrose() { 
            // Impossible Cube approximation
            const arr=[]; const s=500; 
            const edges = [
                [[-s,-s,-s], [s,-s,-s]], [[s,-s,-s], [s,s,-s]], [[s,s,-s], [-s,s,-s]], [[-s,s,-s], [-s,-s,-s]], // Back face
                [[-s,-s,s], [s,-s,s]], [[s,-s,s], [s,s,s]], [[s,s,s], [-s,s,s]], [[-s,s,s], [-s,-s,s]],       // Front face
                [[-s,-s,-s], [-s,-s,s]], [[s,-s,-s], [s,-s,s]], [[s,s,-s], [s,s,s]], [[-s,s,-s], [-s,s,s]]     // Connecting
            ];
            const pointsPerEdge = Math.floor(particleCount / edges.length);
            
            edges.forEach(edge => {
                const [start, end] = edge;
                for(let i=0; i<pointsPerEdge; i++) {
                    const t = Math.random();
                    // Perturb line to make it thick/fuzzy
                    const jitter = 20;
                    arr.push(
                        start[0] + (end[0]-start[0])*t + (Math.random()-0.5)*jitter,
                        start[1] + (end[1]-start[1])*t + (Math.random()-0.5)*jitter,
                        start[2] + (end[2]-start[2])*t + (Math.random()-0.5)*jitter
                    );
                }
            });
            return arr;
        }
        function getTornado() { const arr=[]; const h=rand(800,1200); const top=rand(2,5); for(let i=0;i<particleCount;i++){ const y=(i/particleCount)*h-h/2; const t=(y+h/2)/h; const r=20+t*400*top; const a=y*0.1; const n=(Math.random()-0.5)*50*t; arr.push(Math.cos(a)*r+n, y+(Math.random()-0.5)*20, Math.sin(a)*r+n); } return arr; }
        function getDNA() { const arr=[]; const twist=0.1; const rad=200; const len=1500; for(let i=0;i<particleCount;i++){ const l=i%2===0?1:-1; const t=(i/particleCount)*len-len/2; const a=t*twist; const n=(Math.random()-0.5)*20; arr.push(Math.cos(a+l*Math.PI)*rad+n, Math.sin(a+l*Math.PI)*rad+n, t+(Math.random()-0.5)*50); } return arr; }
        function getAtom() { const arr=[]; const ns=100; const o=4; for(let i=0;i<particleCount;i++){ if(i<particleCount*0.2){ const r=Math.random()*ns; const t=Math.random()*Math.PI*2; const p=Math.acos(2*Math.random()-1); arr.push(r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p)); }else{ const oi=Math.floor(Math.random()*o); const ao=(Math.PI/o)*oi; const t=Math.random()*Math.PI*2; const rad=rand(300,600); const x0=rad*Math.cos(t); const y0=rad*Math.sin(t)*0.3; const z0=(Math.random()-0.5)*20; arr.push(x0*Math.cos(ao)-y0*Math.sin(ao), x0*Math.sin(ao)+y0*Math.cos(ao), z0+x0*Math.sin(ao*2)); } } return arr; }
        
        // Previous Helpers re-used
        function getProceduralGalaxy() { const arr=[]; const arms=5; const spin=0.2; const spread=1.0; for(let i=0;i<particleCount;i++){ const t=Math.random(); const angle=t*Math.PI*2*arms*spin+((i%arms)*Math.PI*2/arms); const r=800*t+50; const nX=(Math.random()-0.5)*200*t*spread; const nY=(Math.random()-0.5)*200*t*spread; const nZ=(Math.random()-0.5)*150*(1-t); arr.push(Math.cos(angle)*r+nX, Math.sin(angle)*r+nY, nZ); } return arr; }

        const shapeGenerators = {
            'Universe': getUniverse, 'Heart': getHeart, 'Mobius': getMobius, 'Penrose': getPenrose, 'Tornado': getTornado,
            'Lorenz': getLorenz, 'Aizawa': getAizawa, 'Thomas': getThomas, 'Halvorsen': getHalvorsen, 'Dadras': getDadras,
            'Sierpinski': getSierpinski, 'Mandelbulb': getMandelbulb, 'DNA': getDNA, 'Atom': getAtom
        };

        // --- Shaders ---
        const vertexShader = `
            uniform float size;
            uniform float uBass;
            uniform float uTreble;
            uniform float uWave;
            uniform float uTime;
            uniform float uModY; 
            varying vec3 vColor;
            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            void main() {
                vColor = color;
                vec3 pos = position;
                pos = pos * (1.0 + uBass * 0.15); 
                if (uWave > 0.05) {
                    float wave = sin(pos.y * 0.02 + uTime * 4.0) * cos(pos.x * 0.02 + uTime * 3.0);
                    float displacement = wave * uWave * 10.0; 
                    pos.x += displacement; 
                    float zScale = 1.0 + abs(wave) * uWave * 3.0;
                }
                if (uModY > 0.01) {
                    float ripple = sin(pos.x * 0.05 + uTime * 5.0) * cos(pos.z * 0.05 + uTime * 2.0);
                    pos.y += ripple * uModY * 30.0; 
                }
                if (uTreble > 0.1) {
                    float r = random(pos.xy + uTime) - 0.5;
                    pos += vec3(r) * uTreble * 3.0;
                }
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                float waveScale = (uWave > 0.05) ? (1.0 + uWave * 1.5) : 1.0;
                float beatScale = 1.0 + uBass * 1.5; 
                gl_PointSize = size * beatScale * waveScale * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform float uShape;
            uniform vec3 uColorTint;
            uniform float uBass;
            uniform float uWave;
            uniform float uModX; 
            varying vec3 vColor;
            void main() {
                vec2 uv = gl_PointCoord;
                float brightness = (1.0 + uBass * 1.2 + uWave * 2.0) * (0.2 + uModX * 1.5);
                vec3 finalColor = vColor * uColorTint * brightness;
                float d = length(uv - 0.5);
                float s0 = exp(-d * d * 12.0); 
                vec2 p = abs(uv - 0.5);
                float s1 = smoothstep(0.4, 0.3, p.x + p.y);
                float s2 = smoothstep(0.4, 0.3, max(p.x, p.y));
                float s3 = smoothstep(0.3, 0.35, d) * smoothstep(0.5, 0.4, d);
                float alpha = 0.0;
                if (uShape < 1.0) alpha = mix(s0, s1, uShape);
                else if (uShape < 2.0) alpha = mix(s1, s2, uShape - 1.0);
                else alpha = mix(s2, s3, uShape - 2.0);
                if (uModX > 0.8) alpha = smoothstep(0.1, 0.9, alpha);
                if (alpha < 0.01) discard;
                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        init();
        setupUIControls();
        setupFileAudio();
        animate();

        function toggleSection(el) { el.parentElement.classList.toggle('collapsed'); }
        window.toggleSection = toggleSection;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 4000);
            camera.position.z = 1000;
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClearColor = false;
            document.body.appendChild(renderer.domElement);

            initParticles(particleCount);
            initLines();
            generateConnections();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            window.addEventListener('resize', onWindowResize, false);

            setTimeout(() => {
                document.getElementById('progress').style.width = "100%";
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                }, 300);
            }, 500);
        }

        function initParticles(count) {
            if (particles) { scene.remove(particles); geometry.dispose(); }
            particleCount = count;
            geometry = new THREE.BufferGeometry();
            material = new THREE.ShaderMaterial({
                uniforms: {
                    size: { value: particleSize },
                    uShape: { value: shapeMorph },
                    uColorTint: { value: new THREE.Color(colorR, colorG, colorB) },
                    uBass: { value: 0.0 }, uTreble: { value: 0.0 }, uWave: { value: 0.0 }, 
                    uModX: { value: 0.5 }, uModY: { value: 0.0 },
                    uTime: { value: 0.0 }
                },
                vertexShader, fragmentShader,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, vertexColors: true
            });
            
            // Initial Shape
            updateParticleGeometry('Universe');
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateParticleGeometry(targetShapeName) {
            const genFunc = shapeGenerators[targetShapeName] || getUniverse;
            const posData = genFunc();
            
            const initialColors = getColors();
            const posArray = new Float32Array(particleCount * 3);
            const colArray = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                // Handle case where generator produces fewer points
                if (i * 3 < posData.length) {
                    posArray[i*3] = posData[i*3]; 
                    posArray[i*3+1] = posData[i*3+1]; 
                    posArray[i*3+2] = posData[i*3+2];
                } else {
                    posArray[i*3] = 0; posArray[i*3+1] = 0; posArray[i*3+2] = 0;
                }
                
                colArray[i*3] = initialColors[i*3]; 
                colArray[i*3+1] = initialColors[i*3+1]; 
                colArray[i*3+2] = initialColors[i*3+2];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));
        }

        function getColors() {
            const arr = [];
            const c = new THREE.Color();
            for (let i = 0; i < particleCount; i++) {
                c.setHSL(Math.random(), 0.8, 0.6); // Generic colors for now
                arr.push(c.r, c.g, c.b);
            }
            return arr;
        }

        function initLines() {
            linesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(maxLines * 2 * 3);
            linesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            linesMesh = new THREE.LineSegments(linesGeometry, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending }));
            linesMesh.frustumCulled = false;
            scene.add(linesMesh);
        }

        function generateConnections() {
            connections = [];
            const positions = particles.geometry.attributes.position.array;
            let attempts = 0;
            while(connections.length < maxLines && attempts < 200000) {
                attempts++;
                const idxA = Math.floor(Math.random() * particleCount);
                const idxB = Math.floor(Math.random() * particleCount);
                if(idxA === idxB) continue;
                const ax = positions[idxA*3], ay = positions[idxA*3+1], az = positions[idxA*3+2];
                const bx = positions[idxB*3], by = positions[idxB*3+1], bz = positions[idxB*3+2];
                if((ax-bx)**2 + (ay-by)**2 + (az-bz)**2 < 6000) connections.push([idxA, idxB]);
            }
        }

        function updateLines() {
            if (!linesMesh || !particles) return;
            const targetCount = Math.floor(connections.length * (neuralDensity / 100));
            linesGeometry.setDrawRange(0, targetCount * 2);
            if (targetCount === 0) return;
            const positions = linesGeometry.attributes.position.array;
            const particlePositions = particles.geometry.attributes.position.array;
            for (let i = 0; i < targetCount; i++) {
                const [a, b] = connections[i];
                positions[i*6] = particlePositions[a*3]; positions[i*6+1] = particlePositions[a*3+1]; positions[i*6+2] = particlePositions[a*3+2];
                positions[i*6+3] = particlePositions[b*3]; positions[i*6+4] = particlePositions[b*3+1]; positions[i*6+5] = particlePositions[b*3+2];
            }
            linesGeometry.attributes.position.needsUpdate = true;
            linesMesh.rotation.copy(particles.rotation);
        }

        // --- File Audio Logic ---
        function setupFileAudio() {
            const fileInput = document.getElementById('audio-file');
            const playBtn = document.getElementById('audio-play-btn');
            const volumeSlider = document.getElementById('audio-volume');
            const gestureBtn = document.getElementById('file-gesture-btn');
            let audioElement = new Audio();
            audioElement.crossOrigin = "anonymous"; 
            audioElement.loop = true;

            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const url = URL.createObjectURL(file);
                audioElement.src = url;
                audioElement.load();
                if (!fileAudioCtx) initFileAudio(audioElement);
                audioElement.play().then(() => {
                    isFilePlaying = true;
                    playBtn.innerText = "PAUSE";
                    logSystem("Audio stream engaged.");
                });
            });

            playBtn.addEventListener('click', () => {
                if(!audioElement.src) { logSystem("No audio source loaded."); return; }
                if(isFilePlaying) {
                    audioElement.pause(); playBtn.innerText = "PLAY"; isFilePlaying = false;
                } else {
                    if(!fileAudioCtx) initFileAudio(audioElement);
                    fileAudioCtx.resume().then(() => {
                        audioElement.play(); playBtn.innerText = "PAUSE"; isFilePlaying = true;
                    });
                }
            });
            volumeSlider.addEventListener('input', (e) => { audioElement.volume = e.target.value; });
            
            document.getElementById('bass-sens-slider').addEventListener('input', (e) => { 
                bassSensitivity = parseFloat(e.target.value); 
                document.getElementById('bass-sens-val').innerText = bassSensitivity.toFixed(1); 
            });
            document.getElementById('treble-sens-slider').addEventListener('input', (e) => { 
                trebleSensitivity = parseFloat(e.target.value); 
                document.getElementById('treble-sens-val').innerText = trebleSensitivity.toFixed(1); 
            });

            gestureBtn.addEventListener('click', toggleGestureMode);
        }

        function initFileAudio(audioElement) {
            fileAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            fileGainNode = fileAudioCtx.createGain(); 
            fileDistortionNode = fileAudioCtx.createWaveShaper(); 
            fileFilterNode = fileAudioCtx.createBiquadFilter();
            fileAnalyser = fileAudioCtx.createAnalyser(); 
            fileDistortionNode.curve = makeDistortionCurve(0);
            fileDistortionNode.oversample = '4x';
            fileFilterNode.type = "lowpass";
            fileFilterNode.frequency.value = 20000;
            fileFilterNode.Q.value = 1;
            fileAnalyser.fftSize = 1024;
            fileAnalyser.smoothingTimeConstant = 0.85;
            fileFreqData = new Uint8Array(fileAnalyser.frequencyBinCount);
            fileTimeData = new Uint8Array(fileAnalyser.frequencyBinCount);
            fileSource = fileAudioCtx.createMediaElementSource(audioElement);
            fileSource.connect(fileGainNode);
            fileGainNode.connect(fileDistortionNode);
            fileDistortionNode.connect(fileFilterNode);
            fileFilterNode.connect(fileAnalyser);
            fileAnalyser.connect(fileAudioCtx.destination);
        }

        function toggleGestureMode() {
            isGestureActive = !isGestureActive;
            const btn = document.getElementById('file-gesture-btn');
            const hint = document.getElementById('gesture-hint');
            if (isGestureActive) {
                btn.classList.add('active'); hint.style.opacity = 1; logSystem("XY Gesture Modulation: ENGAGED");
            } else {
                btn.classList.remove('active'); hint.style.opacity = 0;
                if(fileFilterNode) { fileFilterNode.frequency.value = 20000; fileFilterNode.Q.value = 1; }
                if(fileDistortionNode) fileDistortionNode.curve = makeDistortionCurve(0);
                logSystem("XY Gesture Modulation: DISENGAGED");
            }
        }

        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function drawVisualizer(canvasCtx, freqData, timeData) {
            const width = canvasCtx.canvas.width; const height = canvasCtx.canvas.height;
            canvasCtx.fillStyle = 'rgba(0, 20, 40, 1)'; canvasCtx.fillRect(0, 0, width, height);
            const barWidth = (width / freqData.length) * 2.5; let x = 0;
            for(let i = 0; i < freqData.length; i++) {
                const barHeight = freqData[i] / 4; const r = barHeight + (50 * (i/freqData.length)); const g = 200 * (i/freqData.length); const b = 255;
                canvasCtx.fillStyle = `rgba(${r},${g},${b}, 0.5)`; canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight); x += barWidth + 1;
            }
            if (timeData) {
                canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#0ff'; canvasCtx.beginPath();
                const sliceWidth = width * 1.0 / timeData.length; let startX = 0;
                for(let i = 0; i < timeData.length; i++) {
                    const v = timeData[i] / 128.0; const y = v * height / 2;
                    if(i === 0) canvasCtx.moveTo(startX, y); else canvasCtx.lineTo(startX, y); startX += sliceWidth;
                }
                canvasCtx.lineTo(width, height / 2); canvasCtx.stroke();
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            frames++;
            if (time >= lastTime + 1000) {
                fpsCounter.innerText = Math.round((frames * 1000) / (time - lastTime));
                lastTime = time; frames = 0;
            }
            TWEEN.update();
            if (neuralDensity > 0) updateLines();
            else if (linesMesh && linesMesh.visible) linesGeometry.setDrawRange(0, 0); 

            let bassFactor = 0;
            let trebleFactor = 0;
            let waveFactor = 0;
            
            if (isFilePlaying && fileAnalyser && material) {
                fileAnalyser.getByteFrequencyData(fileFreqData);
                fileAnalyser.getByteTimeDomainData(fileTimeData);
                drawVisualizer(fileVizCtx, fileFreqData, fileTimeData);

                let bassSum = 0; const bassLimit = Math.floor(fileFreqData.length * 0.1);
                let trebleSum = 0; const trebleStart = Math.floor(fileFreqData.length * 0.6);

                for(let i = 0; i < fileFreqData.length; i++) {
                    if (i < bassLimit) bassSum += fileFreqData[i];
                    else if (i > trebleStart) trebleSum += fileFreqData[i];
                }
                let timeSum = 0;
                for(let i=0; i < fileTimeData.length; i++) timeSum += Math.abs(fileTimeData[i] - 128);

                bassFactor = (bassSum / bassLimit) / 255;
                trebleFactor = (trebleSum / (fileFreqData.length - trebleStart)) / 255;
                waveFactor = (timeSum / fileTimeData.length) / 64;

                if (isGestureActive && isPinching) waveFactor += 0.5;

                bassFactor *= bassSensitivity;
                trebleFactor *= trebleSensitivity;

                material.uniforms.uBass.value = THREE.MathUtils.lerp(material.uniforms.uBass.value, bassFactor, 0.1);
                material.uniforms.uTreble.value = THREE.MathUtils.lerp(material.uniforms.uTreble.value, trebleFactor, 0.1);
                material.uniforms.uWave.value = THREE.MathUtils.lerp(material.uniforms.uWave.value, waveFactor > 0.1 ? waveFactor : 0, 0.1);
                
                let targetModX = 0.5;
                let targetModY = 0.0;
                if (isGestureActive) { targetModX = normMouseX; targetModY = 1.0 - normMouseY; }
                material.uniforms.uModX.value = THREE.MathUtils.lerp(material.uniforms.uModX.value, targetModX, 0.1);
                material.uniforms.uModY.value = THREE.MathUtils.lerp(material.uniforms.uModY.value, targetModY, 0.1);

            } else if (pulseIntensity > 0 && material) {
                const pulse = Math.sin(time * 0.003 * (1 + pulseIntensity)) * 0.5 + 0.5; 
                material.uniforms.uBass.value = pulse * pulseIntensity * 0.5;
                material.uniforms.uTreble.value = 0.0;
                material.uniforms.uWave.value = 0.0;
            } else if (material) {
                material.uniforms.uBass.value = 0.0; material.uniforms.uTreble.value = 0.0; material.uniforms.uWave.value = 0.0;
            }
            
            if (material) material.uniforms.uTime.value = time * 0.001;

            const rotationSpeed = 0.001 * simSpeed;
            let chaosMultiplier = (1.0 - stability) * 5;

            if (autoRotate) {
                const extraSpeed = isFilePlaying ? 0.005 : 0;
                particles.rotation.y += (0.002 + extraSpeed);
                if(linesMesh) linesMesh.rotation.y += (0.002 + extraSpeed);
            }

            particles.rotation.y += rotationSpeed * (1 + chaosMultiplier * Math.random());
            particles.rotation.z += rotationSpeed * 0.2 * (1 - chaosMultiplier * Math.random());

            if (stability < 0.95) {
                const shakeIntensity = (1.0 - stability) * 10;
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
            }

            camera.position.x += (mouseX - camera.position.x) * 0.05 * simSpeed;
            camera.position.y += (-mouseY - camera.position.y) * 0.05 * simSpeed;
            camera.lookAt(scene.position);

            renderer.autoClearColor = false;
            renderer.clear(); 
            renderer.render(scene, camera);
        }

        function setupUIControls() {
            document.getElementById('particle-slider').addEventListener('change', (e) => { initParticles(parseInt(e.target.value)); generateConnections(); });
            document.getElementById('particle-slider').addEventListener('input', (e) => document.getElementById('particle-val').innerText = parseInt(e.target.value).toLocaleString());
            document.getElementById('speed-slider').addEventListener('input', (e) => { simSpeed = parseFloat(e.target.value); document.getElementById('speed-val').innerText = simSpeed.toFixed(1)+"x"; });
            document.getElementById('stability-slider').addEventListener('input', (e) => { stability = e.target.value/100; document.getElementById('stability-val').innerText = e.target.value+"%"; });
            document.getElementById('size-slider').addEventListener('input', (e) => { particleSize = parseFloat(e.target.value); document.getElementById('size-val').innerText = particleSize.toFixed(1); if(material) material.uniforms.size.value = particleSize; });
            
            const updateColor = () => {
                colorR = document.getElementById('slider-r').value/255; colorG = document.getElementById('slider-g').value/255; colorB = document.getElementById('slider-b').value/255;
                document.getElementById('rgb-val').innerText = `${parseInt(colorR*255)}, ${parseInt(colorG*255)}, ${parseInt(colorB*255)}`;
                if(material) material.uniforms.uColorTint.value.setRGB(colorR, colorG, colorB);
                if(linesMesh) linesMesh.material.color.setRGB(colorR, colorG * 1.2, colorB * 1.5);
            };
            document.getElementById('slider-r').addEventListener('input', updateColor);
            document.getElementById('slider-g').addEventListener('input', updateColor);
            document.getElementById('slider-b').addEventListener('input', updateColor);

            document.getElementById('neural-slider').addEventListener('input', (e) => { neuralDensity = parseInt(e.target.value); document.getElementById('neural-val').innerText = neuralDensity+"%"; });
            document.getElementById('btn-refresh-lines').addEventListener('click', () => { generateConnections(); });
            
            document.getElementById('shape-slider').addEventListener('input', (e) => { shapeMorph = parseFloat(e.target.value); if(material) material.uniforms.uShape.value = shapeMorph; 
                let txt = "Glow"; if(shapeMorph>0.5) txt="Diamond"; if(shapeMorph>1.5) txt="Square"; if(shapeMorph>2.5) txt="Ring"; document.getElementById('shape-val').innerText=txt; });
            
            document.getElementById('toggle-rotate').addEventListener('click', function() { autoRotate = !autoRotate; this.classList.toggle('active'); });
            document.getElementById('pulse-slider').addEventListener('input', (e) => { pulseIntensity = parseFloat(e.target.value); document.getElementById('pulse-val').innerText = (pulseIntensity*100).toFixed(0)+"%"; });
        }

        function onDocumentMouseMove(event) { 
            mouseX = (event.clientX - windowHalfX) * 1; 
            mouseY = (event.clientY - windowHalfY) * 1; 
            
            if (isGestureActive && fileFilterNode) {
                normMouseX = event.clientX / window.innerWidth; 
                normMouseY = event.clientY / window.innerHeight; 
                
                document.getElementById('mod-cutoff-bar').style.width = (normMouseX * 100) + "%";
                document.getElementById('mod-res-bar').style.width = ((1-normMouseY) * 100) + "%";

                const minFreq = 100;
                const maxFreq = 10000;
                const freq = minFreq + (maxFreq - minFreq) * normMouseX;
                fileFilterNode.frequency.setTargetAtTime(freq, fileAudioCtx.currentTime, 0.1);
                
                const maxQ = 20;
                const q = maxQ * (1 - normMouseY); 
                fileFilterNode.Q.setTargetAtTime(q, fileAudioCtx.currentTime, 0.1);
            }
        }

        function onDocumentMouseDown(event) {
            if (isGestureActive && fileDistortionNode) {
                isPinching = true;
                fileDistortionNode.curve = makeDistortionCurve(400); 
                document.body.style.cursor = 'grabbing';
            }
        }

        function onDocumentMouseUp(event) {
            if (isGestureActive && fileDistortionNode) {
                isPinching = false;
                fileDistortionNode.curve = makeDistortionCurve(0);
                document.body.style.cursor = 'default';
            }
        }

        function onWindowResize() { windowHalfX = window.innerWidth/2; windowHalfY = window.innerHeight/2; camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        
        function logSystem(msg) { const log = document.getElementById('ai-log'); log.innerHTML += `\n[SYS] ${msg}`; log.scrollTop = log.scrollHeight; }
        function toggleMix(name) {
            const tags = document.querySelectorAll('.mix-tag'); let t=null; tags.forEach(tag=>{if(tag.innerText===name)t=tag;});
            if(activeMixShapes.has(name)){ activeMixShapes.delete(name); if(t)t.classList.remove('selected'); }
            else{ activeMixShapes.add(name); if(t)t.classList.add('selected'); }
        }
        
        function selectShape(shapeName) {
            document.querySelectorAll('.math-tag').forEach(t => t.classList.remove('selected'));
            // Add visual selection if needed, or just trigger
            logSystem(`Mathematical Model Selected: ${shapeName}`);
            currentShape = shapeName;
            
            // Reset mix if single select
            activeMixShapes.clear();
            document.querySelectorAll('.mix-tag').forEach(t => t.classList.remove('selected'));
            
            updateParticleGeometry(shapeName);
            
            // Tween effect for transition (Visual feedback)
            if (currentTween) currentTween.stop();
            transitionParams.val = 0;
            currentTween = new TWEEN.Tween(transitionParams)
                .to({ val: 1 }, 2000)
                .easing(TWEEN.Easing.Exponential.InOut)
                .start(); // We are just using this to trigger updates if we were interpolating positions
                          // But here we just swapped the buffer entirely for instant math accuracy.
                          // If we wanted smooth transitions, we'd need double buffering of positions.
                          // For math accuracy on attractors, direct replacement is often cleaner.
            generateConnections(); // Re-link
        }

        // Exports to window
        window.toggleSection = toggleSection;
        window.toggleMix = toggleMix;
        window.selectShape = selectShape;
    </script>
</body>
</html>
