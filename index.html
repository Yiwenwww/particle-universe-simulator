<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaos Universe: Elemental Edition</title>
    <style>
        /* --- 全局设置 --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; transition: background-color 1.5s ease; }
        canvas { display: block; }

        /* --- UI 容器 --- */
        #hologram-ui {
            position: absolute; top: 20px; left: 20px; width: 380px;
            pointer-events: auto; 
            z-index: 10; max-height: 90vh;
            overflow-y: auto; 
            padding-right: 5px;
            scrollbar-width: thin;
            scrollbar-color: #0ff rgba(0, 20, 40, 0.5);
            transition: max-height 0.3s ease;
        }

        /* 针对浅色背景风格的 UI 适配类 */
        body.light-mode #hologram-ui {
            scrollbar-color: #555 rgba(200, 200, 200, 0.5);
        }
        body.light-mode .panel-frame {
            background: rgba(245, 240, 230, 0.85); /* 适配更黄的宣纸背景 */
            border: 1px solid rgba(120, 100, 80, 0.3);
            border-left: 4px solid rgba(80, 60, 40, 0.8);
            color: #333;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
        }
        body.light-mode h1 {
            color: #4a3b2a; text-shadow: none; border-bottom-color: rgba(0,0,0,0.2);
        }
        body.light-mode .section-title {
            color: #5d4e3c; background: rgba(0,0,0,0.05);
        }
        body.light-mode .control-header, body.light-mode .control-value {
            color: #444;
        }
        body.light-mode .math-tag {
            border-color: rgba(100,80,60,0.2); color: #555; background: rgba(0,0,0,0.05);
        }
        body.light-mode .math-tag.selected {
            background: #4a3b2a; color: #fff; border-color: #4a3b2a;
        }
        body.light-mode .ai-log {
            color: #333; background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.1);
        }
        body.light-mode .refresh-btn {
             background: rgba(0,0,0,0.1); color: #333; border-color: #666;
        }
        body.light-mode .sci-fi-btn-small {
            color: #333; border-color: #888; background: rgba(0,0,0,0.05);
        }
        body.light-mode .sci-fi-btn-small:hover {
            color: #fff; background: #4a3b2a; border-color: #4a3b2a;
        }

        /* 收缩状态样式 */
        #hologram-ui.minimized {
            max-height: 45px !important;
            overflow: hidden;
        }

        /* --- 自定义滚动条样式 --- */
        #hologram-ui::-webkit-scrollbar { width: 6px; display: block; }
        #hologram-ui::-webkit-scrollbar-track { background: rgba(0, 20, 40, 0.5); border-left: 1px solid rgba(0, 255, 255, 0.1); }
        #hologram-ui::-webkit-scrollbar-thumb { background: rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.5); border-radius: 3px; }
        
        /* 面板框架 */
        .panel-frame {
            background: rgba(0, 20, 40, 0.85);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 4px solid rgba(0, 255, 255, 0.8);
            padding: 15px; backdrop-filter: blur(6px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            position: relative; overflow: hidden; pointer-events: auto;
            margin-bottom: 10px; transition: all 0.5s ease;
        }
        
        h1 {
            color: #0ff; font-size: 16px; margin: 0 0 12px 0; text-transform: uppercase;
            letter-spacing: 2px; text-shadow: 0 0 5px #0ff; border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 5px; display: flex; justify-content: space-between; align-items: center;
        }
        .fps-badge { font-size: 12px; background: rgba(0, 255, 255, 0.2); padding: 2px 6px; border-radius: 2px; }

        /* 面板折叠按钮 */
        .panel-toggle-btn { cursor: pointer; font-weight: bold; padding: 0 8px; user-select: none; }
        
        /* --- 控件样式 --- */
        .control-section { margin-bottom: 10px; border-bottom: 1px dashed rgba(0,255,255,0.2); padding-bottom: 5px; }
        .section-title {
            color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 8px; opacity: 0.9;
            cursor: pointer; display: flex; justify-content: space-between; align-items: center;
            background: rgba(0, 255, 255, 0.05); padding: 4px; border-radius: 2px; transition: background 0.2s;
        }
        .section-title:hover { background: rgba(0, 255, 255, 0.15); }
        .section-title::after { content: '▼'; font-size: 10px; margin-left: 5px; transition: transform 0.3s; }
        .control-section.collapsed .section-title::after { transform: rotate(-90deg); }
        .section-content { max-height: 800px; overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.3s ease-out; opacity: 1; }
        .control-section.collapsed .section-content { max-height: 0; opacity: 0; }

        .control-row { margin-bottom: 8px; }
        .control-header { display: flex; justify-content: space-between; align-items: center; color: rgba(0, 255, 255, 0.8); font-size: 10px; margin-bottom: 2px; }
        .control-value { color: #fff; font-weight: bold; }

        .refresh-btn {
            background: rgba(0, 0, 0, 0.5); border: 1px solid #0ff; color: #0ff;
            border-radius: 50%; width: 16px; height: 16px; display: flex;
            justify-content: center; align-items: center; cursor: pointer; font-size: 10px; margin-left: 6px; transition: all 0.2s;
        }
        .refresh-btn:hover { background: #0ff; color: #000; transform: rotate(180deg); }

        .toggle-switch {
            position: relative; width: 30px; height: 14px; background: rgba(0, 255, 255, 0.2);
            border-radius: 7px; cursor: pointer; border: 1px solid rgba(0, 255, 255, 0.4);
        }
        .toggle-switch::after {
            content: ''; position: absolute; left: 1px; top: 1px; width: 10px; height: 10px;
            background: #0ff; border-radius: 50%; transition: all 0.3s; box-shadow: 0 0 5px #0ff;
        }
        .toggle-switch.active { background: rgba(0, 255, 255, 0.5); }
        .toggle-switch.active::after { left: 17px; background: #fff; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; margin: 0; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.4); }
        input[type=range]::-webkit-slider-thumb { height: 12px; width: 8px; border: 1px solid #0ff; background: #000; cursor: pointer; -webkit-appearance: none; margin-top: -5px; box-shadow: 0 0 5px #0ff; transition: background 0.2s; }
        input[type=range]::-webkit-slider-thumb:hover { background: #0ff; }

        .slider-red::-webkit-slider-runnable-track { background: rgba(255,0,0,0.3); border-color: rgba(255,0,0,0.5); }
        .slider-red::-webkit-slider-thumb { border-color: #f00; box-shadow: 0 0 5px #f00; }
        .slider-green::-webkit-slider-runnable-track { background: rgba(0,255,0,0.3); border-color: rgba(0,255,0,0.5); }
        .slider-green::-webkit-slider-thumb { border-color: #0f0; box-shadow: 0 0 5px #0f0; }
        .slider-blue::-webkit-slider-runnable-track { background: rgba(0,0,255,0.3); border-color: rgba(0,0,255,0.5); }
        .slider-blue::-webkit-slider-thumb { border-color: #00f; box-shadow: 0 0 5px #00f; }

        .math-tags { display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; }
        .math-tag { font-size: 9px; color: rgba(0,255,255,0.7); border: 1px solid rgba(0,255,255,0.3); padding: 4px 8px; cursor: pointer; transition: all 0.2s; background: rgba(0,0,0,0.3); user-select: none; text-transform: uppercase; flex-grow: 1; text-align: center; }
        .math-tag:hover { background: rgba(0,255,255,0.2); border-color: #0ff; color: #fff; }
        .math-tag.selected { background: rgba(0, 255, 255, 0.6); color: #000; border-color: #fff; }
        .tag-category { width: 100%; font-size: 9px; color: #0ff; margin: 5px 0 2px 0; opacity: 0.7; border-bottom: 1px solid rgba(0,255,255,0.2); }
        body.light-mode .tag-category { color: #555; border-color: #999; }

        .ai-log { font-size: 10px; color: #0f0; height: 50px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 5px; border: 1px solid rgba(0,255,0,0.2); white-space: pre-wrap; line-height: 1.4; transition: all 0.3s; }

        /* 音乐 & 可视化样式 */
        .sci-fi-file-input { font-size: 10px; color: rgba(0, 255, 255, 0.8); width: 100%; background: rgba(0, 0, 0, 0.3); border: 1px dashed rgba(0, 255, 255, 0.3); padding: 5px; cursor: pointer; }
        .sci-fi-btn-small { background: rgba(0, 0, 0, 0.5); border: 1px solid #0ff; color: #0ff; padding: 4px 12px; font-family: inherit; font-size: 10px; cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
        .sci-fi-btn-small:hover { background: #0ff; color: #000; }
        .sci-fi-btn-small.active { background: #0ff; color: #000; box-shadow: 0 0 10px #0ff; }
        
        .viz-canvas { width: 100%; height: 40px; background: rgba(0, 20, 40, 0.5); border: 1px solid rgba(0, 255, 255, 0.2); margin-top: 5px; display: block; }
        
        .mod-bar-container { margin-top: 4px; width: 100%; height: 4px; background: rgba(0,255,255,0.1); position: relative; }
        .mod-bar { height: 100%; background: #0ff; width: 0%; transition: width 0.1s; box-shadow: 0 0 5px #0ff; }

        #loader { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: flex; justify-content: center; align-items: center; color: #0ff; z-index: 100; flex-direction: column; }
        .loader-bar { width: 200px; height: 2px; background: #333; margin-top: 10px; position: relative; }
        .loader-progress { position: absolute; left: 0; top: 0; height: 100%; background: #0ff; width: 0%; transition: width 0.2s; box-shadow: 0 0 10px #0ff; }
        
        #gesture-hint {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0ff; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s;
            text-shadow: 0 0 10px #0ff; border: 1px solid #0ff; padding: 10px; background: rgba(0,0,0,0.7);
            z-index: 20; text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="loader">
        <div>INITIALIZING ART CORE...</div>
        <div class="loader-bar"><div class="loader-progress" id="progress"></div></div>
    </div>
    
    <div id="gesture-hint">
        <div>XY MODULATION ACTIVE</div>
        <div style="font-size:10px; color:#aaa;">X: FILTER | Y: RIPPLE | CLICK: DISTORT</div>
    </div>
    
    <div id="hologram-ui">
        <div class="panel-frame">
            <h1>
                SYSTEM STATUS
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="fps-badge"><span id="fps-counter">60</span> FPS</span>
                    <div class="panel-toggle-btn" onclick="toggleMainPanel(this)">[ - ]</div>
                </div>
            </h1>
            
            <!-- 风格与材质 -->
            <div class="control-section">
                <div class="section-title" onclick="toggleSection(this)">>> VISUAL STYLE & MATERIAL</div>
                <div class="section-content">
                    <div class="tag-category">RENDER STYLE (ENV)</div>
                    <div class="math-tags">
                        <div class="math-tag selected" onclick="setRenderStyle('Universe', this)">Universe</div>
                        <div class="math-tag" onclick="setRenderStyle('Ink', this)">Chinese Ink</div>
                        <div class="math-tag" onclick="setRenderStyle('Oil', this)">Van Gogh Oil</div>
                        <div class="math-tag" onclick="setRenderStyle('Sketch', this)">Sketch</div>
                    </div>
                    <div class="tag-category">ELEMENTAL REALMS (NATURE)</div>
                    <div class="math-tags">
                        <div class="math-tag" onclick="setRenderStyle('Forest', this)">Forest</div>
                        <div class="math-tag" onclick="setRenderStyle('Ocean', this)">Ocean</div>
                        <div class="math-tag" onclick="setRenderStyle('Fire', this)">Fire</div>
                        <div class="math-tag" onclick="setRenderStyle('Cell', this)">Micro-Cell</div>
                    </div>

                    <div class="tag-category">MATERIAL EFFECT (PARTICLES)</div>
                    <div class="math-tags">
                        <div class="math-tag selected" onclick="setMaterialEffect('Particle', this)">Default</div>
                        <div class="math-tag" onclick="setMaterialEffect('Glass', this)">Glass</div>
                        <div class="math-tag" onclick="setMaterialEffect('Plant', this)">Plant</div>
                        <div class="math-tag" onclick="setMaterialEffect('Silk', this)">Silk</div>
                        <div class="math-tag" onclick="setMaterialEffect('Metal', this)">Metal</div>
                        <div class="math-tag" onclick="setMaterialEffect('Rock', this)">Rock</div>
                    </div>
                </div>
            </div>

            <!-- 模拟控制 -->
            <div class="control-section">
                <div class="section-title" onclick="toggleSection(this)">>> SIMULATION CORE</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>PARTICLE DENSITY</span><span class="control-value" id="particle-val">20,000</span></div>
                        <input type="range" id="particle-slider" min="5000" max="50000" step="1000" value="20000">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>TIME DILATION</span><span class="control-value" id="speed-val">1.0x</span></div>
                        <input type="range" id="speed-slider" min="0" max="3" step="0.1" value="1.0">
                    </div>
                </div>
            </div>

            <!-- 动态控制 -->
            <div class="control-section collapsed">
                <div class="section-title" onclick="toggleSection(this)">>> DYNAMICS & MOTION</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>AUTO ROTATION</span><div class="toggle-switch active" id="toggle-rotate"></div></div>
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>PULSE INTENSITY</span><span class="control-value" id="pulse-val">0.0</span></div>
                        <input type="range" id="pulse-slider" min="0" max="1" step="0.01" value="0">
                    </div>
                </div>
            </div>

            <!-- 音乐控制模块 -->
            <div class="control-section collapsed">
                <div class="section-title" onclick="toggleSection(this)">>> SONIC RESONANCE FIELD</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>AUDIO SOURCE</span></div>
                        <input type="file" id="audio-file" accept="audio/*" class="sci-fi-file-input">
                    </div>
                    <div class="control-row" style="display:flex; align-items:center; gap:10px;">
                        <button id="audio-play-btn" class="sci-fi-btn-small">PLAY</button>
                        <button id="file-gesture-btn" class="sci-fi-btn-small" title="Pinch Music (XY Pad)">XY MOD</button>
                        <div style="flex:1">
                            <div class="control-header" style="margin-bottom:0;"><span>VOL</span></div>
                            <input type="range" id="audio-volume" min="0" max="1" step="0.01" value="0.5">
                        </div>
                    </div>
                    
                    <div class="control-row" style="margin-top:10px;">
                        <div class="control-header"><span>MODULATION MONITOR</span></div>
                        <div class="mod-bar-container"><div id="mod-cutoff-bar" class="mod-bar"></div></div>
                    </div>

                    <canvas id="file-visualizer" class="viz-canvas" width="340" height="40"></canvas>
                </div>
            </div>

            <!-- 外观控制 -->
            <div class="control-section collapsed">
                <div class="section-title" onclick="toggleSection(this)">>> FINE TUNING</div>
                <div class="section-content">
                    <div class="control-row">
                        <div class="control-header"><span>PARTICLE SIZE</span><span class="control-value" id="size-val">6.0</span></div>
                        <input type="range" id="size-slider" min="1" max="20" step="0.1" value="6.0">
                    </div>
                    <div class="control-row">
                        <div class="control-header"><span>SPECTRAL FILTER (RGB)</span><span class="control-value" id="rgb-val">255, 255, 255</span></div>
                        <input type="range" class="slider-red" id="slider-r" min="0" max="255" value="255" style="margin-bottom:4px;">
                        <input type="range" class="slider-green" id="slider-g" min="0" max="255" value="255" style="margin-bottom:4px;">
                        <input type="range" class="slider-blue" id="slider-b" min="0" max="255" value="255">
                    </div>
                    <div class="control-row">
                        <div class="control-header">
                            <span>NEURAL DENSITY (LINES)</span>
                            <div style="display:flex; align-items:center;">
                                <span class="control-value" id="neural-val" style="margin-right:5px;">0%</span>
                                <div class="refresh-btn" id="btn-refresh-lines" title="Randomize Connections">↻</div>
                            </div>
                        </div>
                        <input type="range" id="neural-slider" min="0" max="100" step="1" value="0">
                    </div>
                </div>
            </div>
            
            <!-- 数学模型面板 -->
            <div class="control-section" style="border:none; margin-bottom:0;">
                <div class="section-title" onclick="toggleSection(this)">>> DIMENSIONAL RECONSTRUCTOR</div>
                <div class="section-content">
                    <div class="tag-category">GEOMETRY</div>
                    <div class="math-tags">
                        <div class="math-tag selected" onclick="selectShape('Universe')">Universe</div>
                        <div class="math-tag" onclick="selectShape('Heart')">Heart</div>
                        <div class="math-tag" onclick="selectShape('Mobius')">Mobius</div>
                        <div class="math-tag" onclick="selectShape('Penrose')">Penrose</div>
                        <div class="math-tag" onclick="selectShape('Tornado')">Tornado</div>
                    </div>
                    
                    <div class="tag-category">CHAOS ATTRACTORS</div>
                    <div class="math-tags">
                        <div class="math-tag" onclick="selectShape('Lorenz')">Lorenz</div>
                        <div class="math-tag" onclick="selectShape('Aizawa')">Aizawa</div>
                        <div class="math-tag" onclick="selectShape('Dadras')">Dadras</div>
                    </div>

                    <div class="tag-category">FRACTALS & STRUCTURES</div>
                    <div class="math-tags">
                        <div class="math-tag" onclick="selectShape('Sierpinski')">Sierpinski</div>
                        <div class="math-tag" onclick="selectShape('Mandelbulb')">Mandelbulb</div>
                        <div class="math-tag" onclick="selectShape('DNA')">DNA</div>
                        <div class="math-tag" onclick="selectShape('Atom')">Atom</div>
                    </div>

                    <div class="ai-log" id="ai-log">
                        [SYSTEM] Art Core loaded.
                        [INFO] Style Engine Ready.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 3D Variables ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let linesMesh, linesGeometry;
        let connections = [];
        let particleCount = 20000;
        const maxLines = 10000;
        
        // --- Control Variables ---
        let simSpeed = 1.0;
        let particleSize = 6.0;
        let neuralDensity = 0;
        let autoRotate = true;
        let pulseIntensity = 0.0;
        let colorR = 1, colorG = 1, colorB = 1;
        let currentShape = 'universe';
        let currentTween = null;
        const transitionParams = { val: 1 };
        
        // --- Styles & Effects ---
        let currentStyle = 'Universe';
        let currentEffect = 0; // 0: Particle, 1: Glass, 2: Plant, 3: Silk, 4: Metal, 5: Rock

        // --- Audio Settings ---
        let bassSensitivity = 1.0;
        let trebleSensitivity = 1.0;
        let isGestureActive = false;
        let isPinching = false;
        let normMouseX = 0.5, normMouseY = 0.0; 
        let hintTimeout;

        // --- Audio: File Player Variables ---
        let fileAudioCtx, fileAnalyser, fileSource;
        let fileGainNode, fileFilterNode, fileDistortionNode; 
        let isFilePlaying = false;
        let fileFreqData, fileTimeData;
        const fileVizCanvas = document.getElementById('file-visualizer');
        const fileVizCtx = fileVizCanvas.getContext('2d');

        let lastTime = performance.now();
        let frames = 0;
        const fpsCounter = document.getElementById('fps-counter');
        let mouseX = 0, mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        
        const rand = (min, max) => Math.random() * (max - min) + min;

        // --- MATHEMATICAL GENERATORS ---
        function generateAttractor(odeFunc, scale, steps, dt) {
            const arr = [];
            let x = 0.1, y = 0.1, z = 0.1; 
            for(let i=0; i<100; i++) { const d = odeFunc(x,y,z); x+=d.x*dt; y+=d.y*dt; z+=d.z*dt; }
            for(let i=0; i<particleCount; i++) {
                const d = odeFunc(x,y,z); x += d.x * dt; y += d.y * dt; z += d.z * dt;
                const noise = 0.5;
                arr.push(x * scale + (Math.random()-0.5)*noise, y * scale + (Math.random()-0.5)*noise, z * scale + (Math.random()-0.5)*noise);
            }
            return arr;
        }

        function getLorenz() { const sigma=10, rho=28, beta=8/3; return generateAttractor((x,y,z)=>({x:sigma*(y-x),y:x*(rho-z)-y,z:x*y-beta*z}), 15, particleCount, 0.005); }
        function getAizawa() { const a=0.95, b=0.7, c=0.6, d=3.5, e=0.25, f=0.1; return generateAttractor((x,y,z)=>({x:(z-b)*x-d*y,y:d*x+(z-b)*y,z:c+a*z-z*z*z/3-(x*x+y*y)*(1+e*z)+f*z*x*x*x}), 150, particleCount, 0.01); }
        function getDadras() { const p=3, q=2.7, r=1.7, s=2, e=9; return generateAttractor((x,y,z)=>({x:y-p*x+q*y*z,y:r*y-x*z+z,z:s*x*y-e*z}), 40, particleCount, 0.005); }

        function getSierpinski() {
            const arr=[]; const corners=[{x:400,y:-300,z:400},{x:-400,y:-300,z:400},{x:0,y:-300,z:-400},{x:0,y:400,z:0}];
            let cx=0,cy=0,cz=0;
            for(let i=0; i<particleCount; i++) {
                const t=corners[Math.floor(Math.random()*4)]; cx=(cx+t.x)/2; cy=(cy+t.y)/2; cz=(cz+t.z)/2;
                arr.push(cx+(Math.random()-0.5)*5, cy+(Math.random()-0.5)*5, cz+(Math.random()-0.5)*5);
            }
            return arr;
        }

        function getMandelbulb() {
            const arr=[]; for(let i=0;i<particleCount;i++){
                const t=Math.random()*Math.PI*2; const p=Math.acos(2*Math.random()-1); const r=400*Math.pow(Math.random(),1/3); 
                const s=1+0.5*Math.sin(t*8)*Math.cos(p*8);
                arr.push(r*Math.sin(p)*Math.cos(t)*s, r*Math.sin(p)*Math.sin(t)*s, r*Math.cos(p)*s);
            }
            return arr;
        }

        function getUniverse() { const arr=[]; const arms=5; const spin=0.2; const spread=1.0; for(let i=0;i<particleCount;i++){ const t=Math.random(); const angle=t*Math.PI*2*arms*spin+((i%arms)*Math.PI*2/arms); const r=800*t+50; const nX=(Math.random()-0.5)*200*t*spread; const nY=(Math.random()-0.5)*200*t*spread; const nZ=(Math.random()-0.5)*150*(1-t); arr.push(Math.cos(angle)*r+nX, Math.sin(angle)*r+nY, nZ); } return arr; }
        function getHeart() { const arr=[]; for(let i=0;i<particleCount;i++){ const t=Math.random()*Math.PI*2; let x=16*Math.pow(Math.sin(t),3); let y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); let z=(Math.random()-0.5)*10; const s=25; const r=s*(Math.random()*0.2+0.8); arr.push(x*r, y*r, z*s*4*Math.random()); } return arr; }
        function getMobius() { const arr=[]; for(let i=0;i<particleCount;i++){ const u=Math.random()*Math.PI*2; const v=(Math.random()*2)-1; const r=350; const sw=150; arr.push((r+v*sw/2*Math.cos(u/2))*Math.cos(u), (r+v*sw/2*Math.cos(u/2))*Math.sin(u), v*sw/2*Math.sin(u/2)); } return arr; }
        function getPenrose() { const arr=[]; const s=500; const edges=[[[-s,-s,-s],[s,-s,-s]],[[s,-s,-s],[s,s,-s]],[[s,s,-s],[-s,s,-s]],[[-s,s,-s],[-s,-s,-s]],[[-s,-s,s],[s,-s,s]],[[s,-s,s],[s,s,s]],[[s,s,s],[-s,s,s]],[[-s,s,s],[-s,-s,s]],[[-s,-s,-s],[-s,-s,s]],[[s,-s,-s],[s,-s,s]],[[s,s,-s],[s,s,s]],[[-s,s,-s],[-s,s,s]]]; const p=Math.floor(particleCount/edges.length); edges.forEach(e=>{ const[S,E]=e; for(let i=0;i<p;i++){ const t=Math.random(); const j=20; arr.push(S[0]+(E[0]-S[0])*t+(Math.random()-0.5)*j, S[1]+(E[1]-S[1])*t+(Math.random()-0.5)*j, S[2]+(E[2]-S[2])*t+(Math.random()-0.5)*j); }}); return arr; }
        function getTornado() { const arr=[]; const h=rand(800,1200); const top=rand(2,5); for(let i=0;i<particleCount;i++){ const y=(i/particleCount)*h-h/2; const t=(y+h/2)/h; const r=20+t*400*top; const a=y*0.1; const n=(Math.random()-0.5)*50*t; arr.push(Math.cos(a)*r+n, y+(Math.random()-0.5)*20, Math.sin(a)*r+n); } return arr; }
        function getDNA() { const arr=[]; const twist=0.1; const rad=200; const len=1500; for(let i=0;i<particleCount;i++){ const l=i%2===0?1:-1; const t=(i/particleCount)*len-len/2; const a=t*twist; const n=(Math.random()-0.5)*20; arr.push(Math.cos(a+l*Math.PI)*rad+n, Math.sin(a+l*Math.PI)*rad+n, t+(Math.random()-0.5)*50); } return arr; }
        function getAtom() { const arr=[]; const ns=100; const o=4; for(let i=0;i<particleCount;i++){ if(i<particleCount*0.2){ const r=Math.random()*ns; const t=Math.random()*Math.PI*2; const p=Math.acos(2*Math.random()-1); arr.push(r*Math.sin(p)*Math.cos(t), r*Math.sin(p)*Math.sin(t), r*Math.cos(p)); }else{ const oi=Math.floor(Math.random()*o); const ao=(Math.PI/o)*oi; const t=Math.random()*Math.PI*2; const rad=rand(300,600); const x0=rad*Math.cos(t); const y0=rad*Math.sin(t)*0.3; const z0=(Math.random()-0.5)*20; arr.push(x0*Math.cos(ao)-y0*Math.sin(ao), x0*Math.sin(ao)+y0*Math.cos(ao), z0+x0*Math.sin(ao*2)); } } return arr; }

        const shapeGenerators = {
            'Universe': getUniverse, 'Heart': getHeart, 'Mobius': getMobius, 'Penrose': getPenrose, 'Tornado': getTornado,
            'Lorenz': getLorenz, 'Aizawa': getAizawa, 'Dadras': getDadras,
            'Sierpinski': getSierpinski, 'Mandelbulb': getMandelbulb, 'DNA': getDNA, 'Atom': getAtom
        };

        // --- SHADERS (Enhanced) ---
        const vertexShader = `
            uniform float size;
            uniform float uBass;
            uniform float uTreble;
            uniform float uWave;
            uniform float uTime;
            uniform float uModY; 
            uniform int uEffect; 

            varying vec3 vColor;
            varying vec3 vPos;
            varying float vAlpha;

            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) { 
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); 
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ ); 
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vColor = color;
                vec3 pos = position;
                vAlpha = 1.0;

                // --- Effect Logic in Vertex ---
                if (uEffect == 2) { // Plant - Organic Noise
                    float n = snoise(pos * 0.01 + uTime * 0.2);
                    pos += n * 20.0;
                    vColor.g += 0.2; // Green tint
                } 
                else if (uEffect == 3) { // Silk - Wave flow
                    float wave = sin(pos.x * 0.01 + uTime) * 20.0;
                    pos.y += wave;
                    pos.z += cos(pos.y * 0.01 + uTime) * 20.0;
                }
                else if (uEffect == 4) { // Metal - Rigid
                }
                else if (uEffect == 5) { // Rock - Rough
                    float r = random(pos.xy) * 5.0;
                    pos += r;
                }

                // --- Audio Reactivity ---
                pos = pos * (1.0 + uBass * 0.15); 
                if (uWave > 0.05) {
                    float wave = sin(pos.y * 0.02 + uTime * 4.0) * cos(pos.x * 0.02 + uTime * 3.0);
                    pos.x += wave * uWave * 10.0; 
                }
                if (uModY > 0.01) {
                    float ripple = sin(pos.x * 0.05 + uTime * 5.0) * cos(pos.z * 0.05 + uTime * 2.0);
                    pos.y += ripple * uModY * 30.0; 
                }
                
                vPos = pos;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                
                float scale = 1.0;
                if(uEffect == 1) scale = 2.0; 
                if(uEffect == 3) scale = 0.5; 
                
                gl_PointSize = size * scale * (1.0 + uBass * 1.5) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            uniform vec3 uColorTint;
            uniform float uBass;
            uniform int uEffect; 
            uniform int uStyle; // 0:Universe, 1:Ink, 2:Oil, 3:Forest, 4:Sketch, 5:Cell, 6:Ocean, 7:Fire

            varying vec3 vColor;
            varying vec3 vPos;
            varying float vAlpha;

            void main() {
                vec2 uv = gl_PointCoord;
                float dist = length(uv - 0.5);
                if (dist > 0.5) discard;

                vec3 finalColor = vColor * uColorTint;
                float alpha = 1.0;

                // --- Material Effects ---
                if (uEffect == 1) { // Glass
                    float rim = smoothstep(0.4, 0.5, dist);
                    float core = smoothstep(0.1, 0.0, dist);
                    alpha = 0.3 + rim * 0.5; 
                    finalColor += vec3(0.5, 0.8, 1.0) * rim; 
                } 
                else if (uEffect == 4) { // Metal
                    float shine = smoothstep(0.2, 0.3, dist) * smoothstep(0.5, 0.4, dist);
                    finalColor = finalColor * 1.5 + vec3(1.0) * shine;
                    finalColor = pow(finalColor, vec3(1.2)); 
                }
                else if (uEffect == 5) { // Rock
                    alpha = 1.0;
                    if(dist > 0.4) alpha = 0.0; 
                    finalColor *= 0.6; 
                }

                // --- Style Overrides (Post-Processing in Shader) ---
                if (uStyle == 1) { // Ink Wash (Dan Qing - Enhanced Color)
                   float edge = smoothstep(0.5, 0.0, dist);
                   // Less desaturation: Mix gray with color at higher ratio (0.8 instead of 0.4)
                   float gray = dot(finalColor, vec3(0.299, 0.587, 0.114));
                   finalColor = mix(vec3(gray), finalColor, 0.8); 
                   finalColor *= 0.9; 
                   alpha = edge * 0.7; 
                }
                else if (uStyle == 2) { // Oil (Van Gogh)
                   finalColor *= 1.8; 
                   finalColor = pow(finalColor, vec3(1.5)); 
                   float stroke = smoothstep(0.5, 0.45, dist);
                   alpha = stroke;
                }
                else if (uStyle == 4) { // Sketch
                   if (dist > 0.48) discard;
                   finalColor = vec3(0.1); 
                   alpha = 0.7;
                }
                else if (uStyle == 5) { // Cell (Micro)
                   // Membrane look: bright edge, dark center
                   float membrane = smoothstep(0.3, 0.5, dist);
                   alpha = 0.4 + membrane * 0.6;
                   finalColor += vec3(0.2) * membrane; 
                }
                else if (uStyle == 7) { // Fire
                    // Intense core
                    float core = exp(-dist * dist * 15.0);
                    alpha = core;
                    finalColor += vec3(0.5, 0.2, 0.0) * core;
                }
                else {
                    // Standard Universe / Forest / Ocean
                    float glow = exp(-dist * dist * 10.0); 
                    alpha = glow;
                }

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        init();
        setupUIControls();
        setupFileAudio();
        animate();

        function toggleSection(el) { el.parentElement.classList.toggle('collapsed'); }
        function toggleMainPanel(btn) {
            const panel = document.getElementById('hologram-ui');
            panel.classList.toggle('minimized');
            btn.innerText = panel.classList.contains('minimized') ? '[ + ]' : '[ - ]';
        }
        window.toggleSection = toggleSection;
        window.toggleMainPanel = toggleMainPanel;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 4000);
            camera.position.z = 1000;
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            document.body.appendChild(renderer.domElement);

            initParticles(particleCount);
            initLines();
            generateConnections();

            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mouseup', onDocumentMouseUp, false);
            window.addEventListener('resize', onWindowResize, false);

            setTimeout(() => {
                document.getElementById('progress').style.width = "100%";
                setTimeout(() => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                }, 300);
            }, 500);
        }

        function initParticles(count) {
            if (particles) { scene.remove(particles); geometry.dispose(); }
            particleCount = count;
            geometry = new THREE.BufferGeometry();
            
            // Map styles to shader int (Updated Mapping)
            // 0:Universe, 1:Ink, 2:Oil, 3:Forest, 4:Sketch, 5:Cell, 6:Ocean, 7:Fire
            const styleMap = { 
                'Universe':0, 'Ink':1, 'Oil':2, 'Forest':3, 'Sketch':4, 
                'Cell':5, 'Ocean':6, 'Fire':7 
            };
            
            material = new THREE.ShaderMaterial({
                uniforms: {
                    size: { value: particleSize },
                    uColorTint: { value: new THREE.Color(colorR, colorG, colorB) },
                    uBass: { value: 0.0 }, uTreble: { value: 0.0 }, uWave: { value: 0.0 }, 
                    uModX: { value: 0.5 }, uModY: { value: 0.0 },
                    uTime: { value: 0.0 },
                    uEffect: { value: currentEffect },
                    uStyle: { value: styleMap[currentStyle] || 0 }
                },
                vertexShader, fragmentShader,
                blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, vertexColors: true
            });
            
            updateParticleGeometry('Universe');
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Apply current style settings immediately
            setRenderStyle(currentStyle);
        }

        function updateParticleGeometry(targetShapeName) {
            const genFunc = shapeGenerators[targetShapeName] || getUniverse;
            const posData = genFunc();
            
            const initialColors = getColors();
            const posArray = new Float32Array(particleCount * 3);
            const colArray = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                if (i * 3 < posData.length) {
                    posArray[i*3] = posData[i*3]; 
                    posArray[i*3+1] = posData[i*3+1]; 
                    posArray[i*3+2] = posData[i*3+2];
                } else {
                    posArray[i*3] = 0; posArray[i*3+1] = 0; posArray[i*3+2] = 0;
                }
                colArray[i*3] = initialColors[i*3]; 
                colArray[i*3+1] = initialColors[i*3+1]; 
                colArray[i*3+2] = initialColors[i*3+2];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colArray, 3));
        }

        function getColors() {
            const arr = [];
            const c = new THREE.Color();
            for (let i = 0; i < particleCount; i++) {
                c.setHSL(Math.random(), 0.8, 0.6); 
                arr.push(c.r, c.g, c.b);
            }
            return arr;
        }

        function initLines() {
            linesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(maxLines * 2 * 3);
            linesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            linesMesh = new THREE.LineSegments(linesGeometry, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending }));
            linesMesh.frustumCulled = false;
            scene.add(linesMesh);
        }

        function generateConnections() {
            connections = [];
            const positions = particles.geometry.attributes.position.array;
            let attempts = 0;
            while(connections.length < maxLines && attempts < 200000) {
                attempts++;
                const idxA = Math.floor(Math.random() * particleCount);
                const idxB = Math.floor(Math.random() * particleCount);
                if(idxA === idxB) continue;
                const ax = positions[idxA*3], ay = positions[idxA*3+1], az = positions[idxA*3+2];
                const bx = positions[idxB*3], by = positions[idxB*3+1], bz = positions[idxB*3+2];
                if((ax-bx)**2 + (ay-by)**2 + (az-bz)**2 < 6000) connections.push([idxA, idxB]);
            }
        }

        function updateLines() {
            if (!linesMesh || !particles) return;
            const targetCount = Math.floor(connections.length * (neuralDensity / 100));
            linesGeometry.setDrawRange(0, targetCount * 2);
            if (targetCount === 0) return;
            const positions = linesGeometry.attributes.position.array;
            const particlePositions = particles.geometry.attributes.position.array;
            for (let i = 0; i < targetCount; i++) {
                const [a, b] = connections[i];
                positions[i*6] = particlePositions[a*3]; positions[i*6+1] = particlePositions[a*3+1]; positions[i*6+2] = particlePositions[a*3+2];
                positions[i*6+3] = particlePositions[b*3]; positions[i*6+4] = particlePositions[b*3+1]; positions[i*6+5] = particlePositions[b*3+2];
            }
            linesGeometry.attributes.position.needsUpdate = true;
            linesMesh.rotation.copy(particles.rotation);
        }

        // --- Core Logic for Style & Effect ---
        function setRenderStyle(name, el) {
            currentStyle = name;
            // 0:Universe, 1:Ink, 2:Oil, 3:Forest, 4:Sketch, 5:Cell, 6:Ocean, 7:Fire
            const styleMap = { 
                'Universe':0, 'Ink':1, 'Oil':2, 'Forest':3, 'Sketch':4, 
                'Cell':5, 'Ocean':6, 'Fire':7 
            };
            if(material) material.uniforms.uStyle.value = styleMap[name];

            // UI Highlight
            if(el) {
                const siblings = el.parentElement.querySelectorAll('.math-tag');
                siblings.forEach(s => s.classList.remove('selected'));
                el.classList.add('selected');
            }

            // Global Scene Logic
            const body = document.body;
            body.classList.remove('light-mode');
            
            if (name === 'Universe') {
                renderer.setClearColor(0x000000);
                scene.fog.color.setHex(0x000000);
                scene.fog.density = 0.001;
                material.blending = THREE.AdditiveBlending;
                if(linesMesh) { linesMesh.material.color.setHex(0x00ffff); linesMesh.material.blending = THREE.AdditiveBlending; }
                if(material) material.uniforms.uColorTint.value.setRGB(1, 1, 1);
                logSystem("Environment: Deep Space");
            } 
            else if (name === 'Ink') {
                body.classList.add('light-mode');
                // Yellow-ish Rice Paper
                renderer.setClearColor(0xF5E9D3); 
                scene.fog.color.setHex(0xF5E9D3);
                scene.fog.density = 0.0015;
                material.blending = THREE.NormalBlending;
                // Tint for color ink
                if(material) material.uniforms.uColorTint.value.setRGB(0.3, 0.4, 0.5); 
                if(linesMesh) { linesMesh.material.color.setHex(0x554433); linesMesh.material.blending = THREE.NormalBlending; }
                logSystem("Environment: Dan Qing Scroll");
            }
            else if (name === 'Oil') {
                renderer.setClearColor(0x0B0E28);
                scene.fog.color.setHex(0x0B0E28);
                scene.fog.density = 0.001;
                material.blending = THREE.NormalBlending;
                if(material) material.uniforms.uColorTint.value.setRGB(1.0, 0.8, 0.2); 
                if(linesMesh) { linesMesh.material.color.setHex(0xFFA500); linesMesh.material.blending = THREE.AdditiveBlending; }
                logSystem("Environment: Van Gogh Night");
            }
            else if (name === 'Forest') {
                renderer.setClearColor(0x051a05);
                scene.fog.color.setHex(0x051a05);
                material.blending = THREE.AdditiveBlending;
                if(material) material.uniforms.uColorTint.value.setRGB(0.4, 1.0, 0.5); 
                if(linesMesh) { linesMesh.material.color.setHex(0x55ff55); linesMesh.material.blending = THREE.AdditiveBlending; }
                logSystem("Environment: Deep Forest");
            }
            else if (name === 'Ocean') {
                renderer.setClearColor(0x00051a); // Deep Blue
                scene.fog.color.setHex(0x00051a);
                material.blending = THREE.AdditiveBlending;
                if(material) material.uniforms.uColorTint.value.setRGB(0.0, 0.6, 1.0); // Cyan/Blue
                if(linesMesh) { linesMesh.material.color.setHex(0x0088ff); linesMesh.material.blending = THREE.AdditiveBlending; }
                logSystem("Environment: Abyssal Zone");
            }
            else if (name === 'Fire') {
                renderer.setClearColor(0x1a0500); // Dark Red
                scene.fog.color.setHex(0x1a0500);
                material.blending = THREE.AdditiveBlending;
                if(material) material.uniforms.uColorTint.value.setRGB(1.0, 0.4, 0.0); // Orange/Red
                if(linesMesh) { linesMesh.material.color.setHex(0xff4400); linesMesh.material.blending = THREE.AdditiveBlending; }
                logSystem("Environment: Magma Core");
            }
            else if (name === 'Cell') {
                renderer.setClearColor(0x000000);
                scene.fog.color.setHex(0x000000);
                material.blending = THREE.AdditiveBlending;
                // Fluorescent colors
                if(material) material.uniforms.uColorTint.value.setRGB(0.8, 0.0, 1.0); 
                if(linesMesh) { linesMesh.material.color.setHex(0x00ffaa); linesMesh.material.blending = THREE.AdditiveBlending; }
                logSystem("Environment: Microscopic Field");
            }
            else if (name === 'Sketch') {
                body.classList.add('light-mode');
                renderer.setClearColor(0xffffff);
                scene.fog.color.setHex(0xffffff);
                material.blending = THREE.NormalBlending;
                if(material) material.uniforms.uColorTint.value.setRGB(0.1, 0.1, 0.1); 
                if(linesMesh) { linesMesh.material.color.setHex(0x333333); linesMesh.material.blending = THREE.NormalBlending; }
                logSystem("Environment: Drafting Table");
            }
        }

        function setMaterialEffect(name, el) {
            const effectMap = { 'Particle':0, 'Glass':1, 'Plant':2, 'Silk':3, 'Metal':4, 'Rock':5 };
            currentEffect = effectMap[name];
            if(material) material.uniforms.uEffect.value = currentEffect;

            if(el) {
                const siblings = el.parentElement.children;
                for(let s of siblings) s.classList.remove('selected');
                el.classList.add('selected');
            }
            logSystem(`Material Metamorphosis: ${name}`);
        }

        // --- File Audio Logic ---
        function setupFileAudio() {
            const fileInput = document.getElementById('audio-file');
            const playBtn = document.getElementById('audio-play-btn');
            const volumeSlider = document.getElementById('audio-volume');
            const gestureBtn = document.getElementById('file-gesture-btn');
            let audioElement = new Audio();
            audioElement.crossOrigin = "anonymous"; 
            audioElement.loop = true;

            fileInput.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const url = URL.createObjectURL(file);
                audioElement.src = url;
                audioElement.load();
                if (!fileAudioCtx) initFileAudio(audioElement);
                audioElement.play().then(() => {
                    isFilePlaying = true;
                    playBtn.innerText = "PAUSE";
                    logSystem("Audio stream engaged.");
                });
            });

            playBtn.addEventListener('click', () => {
                if(!audioElement.src) { logSystem("No audio source loaded."); return; }
                if(isFilePlaying) {
                    audioElement.pause(); playBtn.innerText = "PLAY"; isFilePlaying = false;
                } else {
                    if(!fileAudioCtx) initFileAudio(audioElement);
                    fileAudioCtx.resume().then(() => {
                        audioElement.play(); playBtn.innerText = "PAUSE"; isFilePlaying = true;
                    });
                }
            });
            volumeSlider.addEventListener('input', (e) => { audioElement.volume = e.target.value; });
            gestureBtn.addEventListener('click', toggleGestureMode);
        }

        function initFileAudio(audioElement) {
            fileAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            fileGainNode = fileAudioCtx.createGain(); 
            fileDistortionNode = fileAudioCtx.createWaveShaper(); 
            fileFilterNode = fileAudioCtx.createBiquadFilter();
            fileAnalyser = fileAudioCtx.createAnalyser(); 
            fileDistortionNode.curve = makeDistortionCurve(0);
            fileDistortionNode.oversample = '4x';
            fileFilterNode.type = "lowpass";
            fileFilterNode.frequency.value = 20000;
            fileFilterNode.Q.value = 1;
            fileAnalyser.fftSize = 1024;
            fileAnalyser.smoothingTimeConstant = 0.85;
            fileFreqData = new Uint8Array(fileAnalyser.frequencyBinCount);
            fileTimeData = new Uint8Array(fileAnalyser.frequencyBinCount);
            fileSource = fileAudioCtx.createMediaElementSource(audioElement);
            fileSource.connect(fileGainNode);
            fileGainNode.connect(fileDistortionNode);
            fileDistortionNode.connect(fileFilterNode);
            fileFilterNode.connect(fileAnalyser);
            fileAnalyser.connect(fileAudioCtx.destination);
        }

        function toggleGestureMode() {
            isGestureActive = !isGestureActive;
            const btn = document.getElementById('file-gesture-btn');
            const hint = document.getElementById('gesture-hint');
            if (isGestureActive) {
                btn.classList.add('active');
                hint.style.opacity = 1;
                clearTimeout(hintTimeout);
                hintTimeout = setTimeout(() => { hint.style.opacity = 0; }, 3000);
                logSystem("XY Gesture Modulation: ENGAGED");
            } else {
                btn.classList.remove('active');
                hint.style.opacity = 0;
                clearTimeout(hintTimeout);
                if(fileFilterNode) { fileFilterNode.frequency.value = 20000; fileFilterNode.Q.value = 1; }
                if(fileDistortionNode) fileDistortionNode.curve = makeDistortionCurve(0);
                logSystem("XY Gesture Modulation: DISENGAGED");
            }
        }

        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function drawVisualizer(canvasCtx, freqData, timeData) {
            const width = canvasCtx.canvas.width; const height = canvasCtx.canvas.height;
            canvasCtx.fillStyle = 'rgba(0, 20, 40, 1)'; canvasCtx.fillRect(0, 0, width, height);
            const barWidth = (width / freqData.length) * 2.5; let x = 0;
            for(let i = 0; i < freqData.length; i++) {
                const barHeight = freqData[i] / 4; const r = barHeight + (50 * (i/freqData.length)); const g = 200 * (i/freqData.length); const b = 255;
                canvasCtx.fillStyle = `rgba(${r},${g},${b}, 0.5)`; canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight); x += barWidth + 1;
            }
            if (timeData) {
                canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = '#0ff'; canvasCtx.beginPath();
                const sliceWidth = width * 1.0 / timeData.length; let startX = 0;
                for(let i = 0; i < timeData.length; i++) {
                    const v = timeData[i] / 128.0; const y = v * height / 2;
                    if(i === 0) canvasCtx.moveTo(startX, y); else canvasCtx.lineTo(startX, y); startX += sliceWidth;
                }
                canvasCtx.lineTo(width, height / 2); canvasCtx.stroke();
            }
        }

        // --- Main Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            frames++;
            if (time >= lastTime + 1000) {
                fpsCounter.innerText = Math.round((frames * 1000) / (time - lastTime));
                lastTime = time; frames = 0;
            }
            TWEEN.update();
            if (neuralDensity > 0) updateLines();
            else if (linesMesh && linesMesh.visible) linesGeometry.setDrawRange(0, 0); 

            let bassFactor = 0;
            let trebleFactor = 0;
            let waveFactor = 0;
            
            if (isFilePlaying && fileAnalyser && material) {
                fileAnalyser.getByteFrequencyData(fileFreqData);
                fileAnalyser.getByteTimeDomainData(fileTimeData);
                drawVisualizer(fileVizCtx, fileFreqData, fileTimeData);

                let bassSum = 0; const bassLimit = Math.floor(fileFreqData.length * 0.1);
                let trebleSum = 0; const trebleStart = Math.floor(fileFreqData.length * 0.6);

                for(let i = 0; i < fileFreqData.length; i++) {
                    if (i < bassLimit) bassSum += fileFreqData[i];
                    else if (i > trebleStart) trebleSum += fileFreqData[i];
                }
                let timeSum = 0;
                for(let i=0; i < fileTimeData.length; i++) timeSum += Math.abs(fileTimeData[i] - 128);

                bassFactor = (bassSum / bassLimit) / 255;
                trebleFactor = (trebleSum / (fileFreqData.length - trebleStart)) / 255;
                waveFactor = (timeSum / fileTimeData.length) / 64;

                if (isGestureActive && isPinching) waveFactor += 0.5;

                bassFactor *= bassSensitivity;
                trebleFactor *= trebleSensitivity;

                material.uniforms.uBass.value = THREE.MathUtils.lerp(material.uniforms.uBass.value, bassFactor, 0.1);
                material.uniforms.uTreble.value = THREE.MathUtils.lerp(material.uniforms.uTreble.value, trebleFactor, 0.1);
                material.uniforms.uWave.value = THREE.MathUtils.lerp(material.uniforms.uWave.value, waveFactor > 0.1 ? waveFactor : 0, 0.1);
                
                let targetModX = 0.5;
                let targetModY = 0.0;
                if (isGestureActive) { targetModX = normMouseX; targetModY = 1.0 - normMouseY; }
                material.uniforms.uModX.value = THREE.MathUtils.lerp(material.uniforms.uModX.value, targetModX, 0.1);
                material.uniforms.uModY.value = THREE.MathUtils.lerp(material.uniforms.uModY.value, targetModY, 0.1);

            } else if (pulseIntensity > 0 && material) {
                const pulse = Math.sin(time * 0.003 * (1 + pulseIntensity)) * 0.5 + 0.5; 
                material.uniforms.uBass.value = pulse * pulseIntensity * 0.5;
                material.uniforms.uTreble.value = 0.0;
                material.uniforms.uWave.value = 0.0;
            } else if (material) {
                material.uniforms.uBass.value = 0.0; material.uniforms.uTreble.value = 0.0; material.uniforms.uWave.value = 0.0;
            }
            
            if (material) material.uniforms.uTime.value = time * 0.001;

            const rotationSpeed = 0.001 * simSpeed;

            if (autoRotate) {
                const extraSpeed = isFilePlaying ? 0.005 : 0;
                particles.rotation.y += (0.002 + extraSpeed);
                if(linesMesh) linesMesh.rotation.y += (0.002 + extraSpeed);
            }

            particles.rotation.y += rotationSpeed;
            particles.rotation.z += rotationSpeed * 0.2;

            camera.position.x += (mouseX - camera.position.x) * 0.05 * simSpeed;
            camera.position.y += (-mouseY - camera.position.y) * 0.05 * simSpeed;
            camera.lookAt(scene.position);

            // Important: We do NOT autoClear if we want trails, but standard mode needs clear
            // Ink mode looks better with autoClear on to prevent mess
            renderer.autoClear = true; 
            renderer.clear(); 
            renderer.render(scene, camera);
        }

        function setupUIControls() {
            document.getElementById('particle-slider').addEventListener('change', (e) => { initParticles(parseInt(e.target.value)); generateConnections(); });
            document.getElementById('particle-slider').addEventListener('input', (e) => document.getElementById('particle-val').innerText = parseInt(e.target.value).toLocaleString());
            document.getElementById('speed-slider').addEventListener('input', (e) => { simSpeed = parseFloat(e.target.value); document.getElementById('speed-val').innerText = simSpeed.toFixed(1)+"x"; });
            document.getElementById('size-slider').addEventListener('input', (e) => { particleSize = parseFloat(e.target.value); document.getElementById('size-val').innerText = particleSize.toFixed(1); if(material) material.uniforms.size.value = particleSize; });
            
            const updateColor = () => {
                colorR = document.getElementById('slider-r').value/255; colorG = document.getElementById('slider-g').value/255; colorB = document.getElementById('slider-b').value/255;
                document.getElementById('rgb-val').innerText = `${parseInt(colorR*255)}, ${parseInt(colorG*255)}, ${parseInt(colorB*255)}`;
                if(material) material.uniforms.uColorTint.value.setRGB(colorR, colorG, colorB);
                if(linesMesh) linesMesh.material.color.setRGB(colorR, colorG * 1.2, colorB * 1.5);
            };
            document.getElementById('slider-r').addEventListener('input', updateColor);
            document.getElementById('slider-g').addEventListener('input', updateColor);
            document.getElementById('slider-b').addEventListener('input', updateColor);

            document.getElementById('neural-slider').addEventListener('input', (e) => { neuralDensity = parseInt(e.target.value); document.getElementById('neural-val').innerText = neuralDensity+"%"; });
            document.getElementById('btn-refresh-lines').addEventListener('click', () => { generateConnections(); });
            
            document.getElementById('toggle-rotate').addEventListener('click', function() { autoRotate = !autoRotate; this.classList.toggle('active'); });
            document.getElementById('pulse-slider').addEventListener('input', (e) => { pulseIntensity = parseFloat(e.target.value); document.getElementById('pulse-val').innerText = (pulseIntensity*100).toFixed(0)+"%"; });
        }

        function onDocumentMouseMove(event) { 
            mouseX = (event.clientX - windowHalfX) * 1; 
            mouseY = (event.clientY - windowHalfY) * 1; 
            
            if (isGestureActive && fileFilterNode) {
                normMouseX = event.clientX / window.innerWidth; 
                normMouseY = event.clientY / window.innerHeight; 
                document.getElementById('mod-cutoff-bar').style.width = (normMouseX * 100) + "%";
                const minFreq = 100; const maxFreq = 10000;
                const freq = minFreq + (maxFreq - minFreq) * normMouseX;
                fileFilterNode.frequency.setTargetAtTime(freq, fileAudioCtx.currentTime, 0.1);
                const maxQ = 20; const q = maxQ * (1 - normMouseY); 
                fileFilterNode.Q.setTargetAtTime(q, fileAudioCtx.currentTime, 0.1);
            }
        }

        function onDocumentMouseDown(event) {
            if (event.target.closest('#hologram-ui') || event.target.closest('#controls')) return; 
            if (isGestureActive && fileDistortionNode) {
                isPinching = true;
                fileDistortionNode.curve = makeDistortionCurve(400); 
                document.body.style.cursor = 'grabbing';
            }
        }

        function onDocumentMouseUp(event) {
            if (isGestureActive && fileDistortionNode) {
                isPinching = false;
                fileDistortionNode.curve = makeDistortionCurve(0);
                document.body.style.cursor = 'default';
            }
        }

        function onWindowResize() { windowHalfX = window.innerWidth/2; windowHalfY = window.innerHeight/2; camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function logSystem(msg) { const log = document.getElementById('ai-log'); log.innerHTML += `\n[SYS] ${msg}`; log.scrollTop = log.scrollHeight; }
        
        function selectShape(shapeName) {
            document.querySelectorAll('.math-tag').forEach(t => t.classList.remove('selected'));
            logSystem(`Model: ${shapeName}`);
            currentShape = shapeName;
            updateParticleGeometry(shapeName);
            if (currentTween) currentTween.stop();
            transitionParams.val = 0;
            currentTween = new TWEEN.Tween(transitionParams).to({ val: 1 }, 2000).easing(TWEEN.Easing.Exponential.InOut).start(); 
            generateConnections(); 
        }

        window.selectShape = selectShape;
        window.setRenderStyle = setRenderStyle;
        window.setMaterialEffect = setMaterialEffect;
    </script>
</body>
</html>
